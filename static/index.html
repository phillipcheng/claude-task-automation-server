<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Cache buster: Force reload - 20251027-streaming-realtime-fix -->
    <title>Phillip Task Automation Server - v20251027-streaming-realtime-fix</title>

    <!-- Favicon and Icons -->
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
    <link rel="shortcut icon" href="/static/favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #ffffff;
            height: 100vh;
            overflow: auto;
            padding: 0;
        }

        /* Only restrict overflow for tabs view */
        body.tabs-view {
            overflow: auto;
        }

        .container {
            max-width: 100%;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: grid;
            grid-template-rows: auto 1fr;
            grid-template-areas:
                "header"
                "content";
        }

        header {
            grid-area: header;
            text-align: center;
            color: #333;
            padding: 0;
            margin: 0;
        }

        header h1 {
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .card {
            background: white;
            padding: 10px;
            margin-bottom: 5px;
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
        }

        input[type="text"],
        input[type="number"],
        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #5568d3;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-success { background: #10b981; }
        .btn-success:hover { background: #059669; }

        .btn-warning { background: #f59e0b; }
        .btn-warning:hover { background: #d97706; }

        .btn-danger { background: #ef4444; }
        .btn-danger:hover { background: #dc2626; }

        .btn-sm {
            padding: 8px 16px;
            font-size: 13px;
        }

        .tasks-list {
            margin-top: 20px;
        }

        /* Batch selection styles */
        .batch-selection-toolbar {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 12px 16px;
            margin-bottom: 16px;
            display: none;
            align-items: center;
            gap: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .batch-selection-toolbar.visible {
            display: flex;
        }

        .batch-selection-info {
            font-weight: 600;
            color: #374151;
        }

        .batch-actions {
            display: flex;
            gap: 8px;
        }

        .batch-actions .btn {
            padding: 6px 12px;
            font-size: 13px;
        }

        .select-all-container {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 12px 16px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .select-all-container label {
            margin: 0;
            font-weight: 600;
            color: #374151;
            cursor: pointer;
        }

        .task-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            margin-right: 12px;
            border: 2px solid #667eea !important;
            background: white !important;
            outline: 2px solid #ff0000 !important; /* Temporary red outline for debugging */
        }

        .task-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .task-item-content {
            flex: 1;
        }

        /* Tab View Styles */
        .tasks-tab-view {
            grid-area: content;
            margin: 0;
            padding: 0;
            height: 100%;
        }

        .tab-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            padding: 0;
        }


        .task-tabs {
            display: flex;
            overflow-x: auto;
            border-bottom: 2px solid #e5e7eb;
            background: #f9fafb;
            padding: 0 10px;
            margin: 0;
            flex-shrink: 0;
        }

        .task-tab {
            flex-shrink: 0;
            padding: 12px 20px;
            border: none;
            background: transparent;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .task-tab:hover {
            background: #e5e7eb;
        }

        .task-tab.active {
            border-bottom-color: #667eea;
            background: white;
            color: #667eea;
        }

        .task-tab-status {
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .task-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;  /* Allow scrolling to see tabs above */
            padding: 0;
            margin: 0;
        }

        /* Add bottom padding only in tabs view to account for fixed input box */
        body.tabs-view .task-content {
            padding-bottom: 50px;
        }

        .no-task-selected {
            text-align: center;
            color: #6b7280;
            padding: 60px 20px;
            font-size: 16px;
        }

        /* Conversation display styles */
        .conversation-item {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #e5e7eb;
        }

        .conversation-item.user_request {
            background: #f0f9ff;
            border-left-color: #3b82f6;
        }

        .conversation-item.claude_response {
            background: #f0fdf4;
            border-left-color: #10b981;
        }

        .conversation-item.tool_result {
            background: #fefce8;
            border-left-color: #f59e0b;
        }

        .conversation-item.user_input {
            background: #faf5ff;
            border-left-color: #8b5cf6;
        }

        .interaction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .interaction-content {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            color: #374151;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .timestamp {
            color: #6b7280;
            font-size: 12px;
        }

        .no-conversation {
            text-align: center;
            color: #6b7280;
            padding: 40px 20px;
            font-style: italic;
        }

        .task-item {
            background: #f9fafb;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 6px;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .task-name {
            font-weight: 600;
            font-size: 1.1em;
            color: #1f2937;
        }

        .task-status {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-pending { background: #fbbf24; color: #92400e; }
        .status-running { background: #3b82f6; color: #ffffff; }
        .status-paused { background: #f59e0b; color: #78350f; }
        .status-stopped { background: #ef4444; color: #ffffff; }
        .status-testing { background: #8b5cf6; color: #ffffff; }
        .status-completed { background: #10b981; color: #ffffff; }
        .status-finished { background: #059669; color: #ffffff; }
        .status-failed { background: #dc2626; color: #ffffff; }
        .status-exhausted { background: #ea580c; color: #ffffff; }

        .task-progress {
            color: #6b7280;
            font-size: 14px;
            margin: 8px 0;
        }

        .task-details {
            background: #f9fafb;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 13px;
        }

        .task-detail-row {
            display: flex;
            gap: 20px;
            margin: 5px 0;
            flex-wrap: wrap;
        }

        .task-detail-item {
            display: flex;
            gap: 5px;
        }

        .task-detail-label {
            font-weight: 600;
            color: #4b5563;
        }

        .task-detail-value {
            color: #6b7280;
            word-break: break-all;
        }

        .task-description {
            background: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 13px;
            color: #374151;
            border-left: 3px solid #667eea;
        }

        .task-claude {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 13px;
            color: #374151;
            border-left: 3px solid #667eea;
        }

        .task-actions {
            display: flex;
            gap: 10px;
            margin-top: 12px;
        }

        .task-metrics {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .metric {
            display: inline-block;
            padding: 4px 8px;
            background: #f3f4f6;
            color: #374151;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .test-summary {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 13px;
        }

        .test-stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .error-message {
            background: #fee2e2;
            color: #991b1b;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 14px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #6b7280;
        }

        .alert {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .alert-success {
            background: #d1fae5;
            color: #065f46;
            border-left: 4px solid #10b981;
        }

        .alert-error {
            background: #fee2e2;
            color: #991b1b;
            border-left: 4px solid #ef4444;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            overflow: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Directory modal should appear above other modals */
        #directoryModal {
            z-index: 99999;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            width: 95%;
            max-width: 1400px;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 2px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            color: #667eea;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6b7280;
        }

        .modal-close:hover {
            color: #374151;
        }

        .modal-body {
            padding: 10px 20px 20px 20px;
            overflow-y: auto;
            flex: 1;
            min-height: 0; /* Allow flex child to shrink below content size */
        }

        .modal-footer {
            padding: 20px;
            border-top: 2px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }

        /* Conversation styles */
        .conversation {
            display: flex;
            flex-direction: column;
            gap: 0;
            height: 100%;
            min-height: 400px;
            overflow-y: auto;
        }

        .message {
            padding: 6px 10px;
            border-radius: 4px;
            border-left: 3px solid;
            margin-bottom: 4px;
        }

        .message-user {
            background: #e0e7ff;
            border-left-color: #667eea;
        }

        .message-claude {
            background: #dbeafe;
            border-left-color: #3b82f6;
        }

        .message-simulated {
            background: #fef3c7;
            border-left-color: #f59e0b;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
            font-size: 10px;
            color: #6b7280;
        }

        .message-type {
            font-weight: 600;
            text-transform: uppercase;
        }

        .message-content {
            color: #1f2937;
            white-space: pre-wrap;
            font-size: 11px;
            line-height: 0.95;
            margin: 0;
            padding: 0;
        }

        /* Collapsible tool results styles */
        .tool-result-collapsed {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            padding: 4px 8px;
            margin: 2px 0;
            cursor: pointer;
            font-size: 10px;
            color: #6b7280;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tool-result-collapsed:hover {
            background: #e5e7eb;
        }

        .tool-result-expanded {
            display: block;
        }

        .tool-result-hidden {
            display: none;
        }

        .expand-icon {
            font-weight: bold;
            font-size: 12px;
        }

        .input-editor {
            margin-top: 20px;
        }

        .input-editor textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
        }

        .input-editor textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Message input box styling */
        .message-input-box {
            margin-top: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f9fa;
            padding: 15px;
        }

        /* Fixed tab input box at bottom */
        .fixed-tab-input {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 1px solid #e5e7eb;
            padding: 4px;
            height: 36px;
            box-sizing: border-box;
            margin: 0;
            z-index: 1000;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
            display: none; /* Hidden by default */
        }

        /* Show input box only in tabs view */
        body.tabs-view .fixed-tab-input {
            display: block;
        }
        .input-header {
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }
        .input-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .input-container input[type="text"] {
            flex: 1;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            background: white;
        }
        .input-container input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }
        .input-container .send-btn {
            padding: 10px 16px;
            margin: 0;
            white-space: nowrap;
        }

        /* Directory Browser */
        .dir-browser {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
        }

        .dir-path {
            background: #f3f4f6;
            padding: 12px;
            font-family: monospace;
            font-size: 13px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dir-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .dir-item {
            padding: 12px;
            border-bottom: 1px solid #f3f4f6;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .dir-item:hover {
            background: #f9fafb;
        }

        .dir-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .dir-item.disabled:hover {
            background: transparent;
        }

        .dir-icon {
            font-size: 16px;
        }

        /* Prompt Library Styles */
        .prompt-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .prompt-item {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .prompt-item:hover {
            background: #f9fafb;
        }

        .prompt-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .prompt-title {
            font-weight: 600;
            font-size: 15px;
            color: #1f2937;
        }

        .prompt-meta {
            display: flex;
            gap: 10px;
            font-size: 12px;
            color: #6b7280;
        }

        .prompt-category {
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .prompt-content-preview {
            color: #4b5563;
            font-size: 13px;
            max-height: 60px;
            overflow: hidden;
            margin-top: 8px;
            line-height: 1.5;
        }

        .prompt-actions {
            margin-top: 10px;
            display: flex;
            gap: 8px;
        }

        .prompt-usage {
            font-size: 11px;
            color: #9ca3af;
        }

        /* Project Configuration Styles */
        .project-item {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            position: relative;
        }

        .project-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .project-title {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .project-remove {
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .project-remove:hover {
            background: #b91c1c;
        }

        .project-fields {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 10px;
            align-items: end;
        }

        .project-field {
            display: flex;
            flex-direction: column;
        }

        .project-field label {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
        }

        .project-field input,
        .project-field select {
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 13px;
        }

        .project-field input:focus,
        .project-field select:focus {
            outline: none;
            border-color: #667eea;
        }

        .projects-empty {
            text-align: center;
            color: #9ca3af;
            font-style: italic;
            padding: 20px;
        }

        /* Animation for streaming indicator */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Radio button styling for view mode */
        .view-mode-radio:hover {
            background-color: #e5e7eb !important;
            border-color: #d1d5db !important;
        }

        .view-mode-radio:has(input:checked) {
            background-color: #667eea !important;
            border-color: #667eea !important;
            color: white !important;
        }

        .view-mode-radio:has(input:checked) span {
            color: white !important;
        }

        .view-mode-radio input[type="radio"] {
            accent-color: #667eea;
        }

        /* Conversation Navigation Sidebar */
        .conversation-nav-container {
            position: relative;
            display: flex;
            height: 100%;
        }

        .conversation-nav-sidebar {
            width: 20px;
            min-width: 20px;
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            border-left: 1px solid #cbd5e1;
            position: relative;
            flex-shrink: 0;
            cursor: pointer;
        }

        .conversation-nav-indicator {
            width: 8px;
            height: 12px;
            margin: 2px auto;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            background: linear-gradient(135deg, #64748b, #475569);
            border: 1px solid #334155;
        }

        .conversation-nav-indicator:hover {
            transform: scale(1.2);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .conversation-nav-indicator.human {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: 1px solid #1e40af;
        }

        .conversation-nav-indicator.claude {
            background: linear-gradient(135deg, #10b981, #047857);
            border: 1px solid #065f46;
        }

        .conversation-nav-indicator.system {
            background: linear-gradient(135deg, #6b7280, #374151);
            border: 1px solid #1f2937;
        }

        .conversation-nav-indicator.tool {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: 1px solid #92400e;
        }

        /* Minimap-style navigation */
        .conversation-minimap {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            padding: 1px;
        }

        .conversation-minimap-item {
            width: 100%;
            position: relative;
            transition: all 0.2s ease;
            cursor: pointer;
            border-radius: 1px;
            margin-bottom: 1px;
            min-height: 2px;
        }

        .conversation-minimap-item:hover {
            transform: scaleX(1.3);
            box-shadow: 0 0 4px rgba(0,0,0,0.4);
            z-index: 5;
        }

        /* Clear color coding for different message types */
        .conversation-minimap-item.human {
            background: #2563eb; /* Bright blue for user messages */
            box-shadow: 1px 0 2px rgba(37, 99, 235, 0.4);
        }

        .conversation-minimap-item.claude {
            background: #059669; /* Bright emerald for Claude messages */
            box-shadow: 1px 0 2px rgba(5, 150, 105, 0.4);
        }

        .conversation-minimap-item.tool {
            background: #dc2626; /* Bright red for tool results */
            box-shadow: 1px 0 2px rgba(220, 38, 38, 0.4);
        }

        .conversation-minimap-item.system {
            background: #4b5563; /* Dark gray for system messages */
            box-shadow: 1px 0 2px rgba(75, 85, 99, 0.4);
        }

        .conversation-viewport-indicator {
            position: absolute;
            left: 0;
            right: 0;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid #ef4444;
            border-radius: 1px;
            pointer-events: none;
            transition: all 0.1s ease;
            z-index: 10;
            min-height: 10px;
        }

        /* JavaScript-based tooltip */
        .nav-tooltip {
            position: fixed;
            left: auto;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            z-index: 10000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0;
            transition: opacity 0.15s ease-out;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .nav-tooltip.show {
            opacity: 1;
        }

        .conversation-content {
            flex: 1;
            /* Remove overflow-y: auto to prevent double-scrolling */
            /* The inner tabConversationContainer will handle scrolling */
        }
    </style>
</head>
<body class="tabs-view">
    <div class="container">

        <!-- Create Task Form (Initially Hidden) -->
        <div class="card" id="createTaskCard" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">Create New Task</h2>
                <button onclick="toggleCreateForm()" class="btn btn-sm">‚úï Close</button>
            </div>
            <div id="createAlert"></div>
            <form id="createTaskForm">
                <div class="form-group">
                    <label for="taskName">Task Name *</label>
                    <input type="text" id="taskName" placeholder="e.g., add-login-feature" required>
                </div>
                <div class="form-group">
                    <label for="description">
                        Description *
                        <button type="button" onclick="openPromptLibrary('description')" class="btn btn-sm" style="float: right; margin-left: 10px;" title="Load from prompt library">
                            üìö Load Prompt
                        </button>
                        <button type="button" onclick="saveCurrentPrompt('description')" class="btn btn-sm" style="float: right;" title="Save current text as prompt">
                            üíæ Save as Prompt
                        </button>
                    </label>
                    <textarea id="description" placeholder="Describe what Claude should implement..." required></textarea>
                </div>
                <div class="form-group">
                    <label>Projects Configuration *</label>


                    <div id="projectsList" style="border: 2px solid #e0e0e0; border-radius: 6px; padding: 15px; min-height: 120px;">
                        <!-- Projects will be dynamically added here -->
                    </div>
                    <button type="button" onclick="addProject()" class="btn btn-sm" style="margin-top: 10px;">
                        ‚ûï Add Project
                    </button>
                </div>
                <div class="form-group">
                    <label for="endCriteria">Ending Criteria (optional)</label>
                    <button type="button" onclick="openPromptLibrary('endCriteria')" class="btn btn-sm" style="float: right; margin-left: 10px;" title="Load from prompt library">
                        üìö Load Prompt
                    </button>
                    <button type="button" onclick="saveCurrentPrompt('endCriteria')" class="btn btn-sm" style="float: right;" title="Save current text as prompt">
                        üíæ Save as Prompt
                    </button>
                    <textarea id="endCriteria" placeholder="Leave empty to auto-extract from description. Example: 'Build runs successfully with zero errors'"></textarea>
                    <small style="color: #6b7280; font-size: 12px; margin-top: 4px; display: block;">
                        System will attempt to auto-extract success criteria from description if not provided. Use the Prompt Library to save/load common criteria templates.
                    </small>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div class="form-group">
                        <label for="maxIterations">Max Iterations (default: 20)</label>
                        <input type="number" id="maxIterations" placeholder="20" min="1">
                    </div>
                    <div class="form-group">
                        <label for="maxTokens">Max Output Tokens (optional)</label>
                        <input type="number" id="maxTokens" placeholder="No limit" min="1000">
                    </div>
                </div>
                <div class="form-group checkbox-group">
                    <input type="checkbox" id="useWorktree" checked>
                    <label for="useWorktree">Use Git Worktree (recommended for parallel tasks)</label>
                </div>
                <div class="form-group checkbox-group">
                    <input type="checkbox" id="autoStart">
                    <label for="autoStart">Auto-start task immediately</label>
                </div>
                <button type="submit" class="btn">Create Task</button>
            </form>
        </div>

        <!-- Saved Projects Panel (Initially Hidden) -->
        <div class="card" id="projectsPanel" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">üìÅ Saved Projects</h2>
                <button onclick="toggleProjectsPanel()" class="btn btn-sm">‚úï Close</button>
            </div>
            <div id="projectsAlert"></div>

            <!-- Add Project Form -->
            <div style="background: #f9fafb; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0; font-size: 14px;">Add New Project</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label for="newProjectName">Project Name *</label>
                        <input type="text" id="newProjectName" placeholder="e.g., Main Service">
                    </div>
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label for="newProjectPath">Path *</label>
                        <input type="text" id="newProjectPath" placeholder="/path/to/project">
                    </div>
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label for="newProjectAccess">Default Access</label>
                        <select id="newProjectAccess" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 6px;">
                            <option value="write">Write</option>
                            <option value="read">Read</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label for="newProjectBranch">Default Branch (optional)</label>
                        <input type="text" id="newProjectBranch" placeholder="main">
                    </div>
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label for="newProjectContext">Context (optional)</label>
                    <textarea id="newProjectContext" placeholder="Description for Claude..." style="min-height: 60px;"></textarea>
                </div>
                <button onclick="createSavedProject()" class="btn btn-sm btn-success">+ Add Project</button>
            </div>

            <!-- Saved Projects List -->
            <div id="savedProjectsList" style="border: 1px solid #e5e7eb; border-radius: 6px;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #f3f4f6;">
                            <th style="padding: 10px; text-align: left; font-size: 13px;">Name</th>
                            <th style="padding: 10px; text-align: left; font-size: 13px;">Path</th>
                            <th style="padding: 10px; text-align: left; font-size: 13px;">Access</th>
                            <th style="padding: 10px; text-align: left; font-size: 13px;">Branch</th>
                            <th style="padding: 10px; text-align: left; font-size: 13px;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="savedProjectsTableBody">
                        <tr><td colspan="5" style="padding: 20px; text-align: center; color: #6b7280;">Loading projects...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Task List -->
        <div class="card">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div>
                    <button onclick="toggleCreateForm()" class="btn btn-sm">+ Add Task</button>
                    <button onclick="refreshTasksKeepingTab('running')" class="btn btn-sm">Show Running</button>
                    <button onclick="refreshTasksKeepingTab('pending')" class="btn btn-sm">Show Pending</button>
                    <button onclick="refreshTasksKeepingTab()" class="btn btn-sm">Show All</button>
                    <button onclick="toggleProjectsPanel()" class="btn btn-sm" style="background: #8b5cf6;">üìÅ Projects</button>
                    <div style="margin-left: 15px; display: inline-block;">
                        <div style="font-size: 13px; color: #6b7280; display: flex; align-items: center; gap: 12px; margin: 0;">
                            <span>View:</span>
                            <label class="view-mode-radio" style="display: flex; align-items: center; gap: 4px; cursor: pointer; padding: 6px 12px; border-radius: 6px; transition: all 0.2s; background-color: #f3f4f6; border: 1px solid #e5e7eb;">
                                <input type="radio" name="viewMode" value="list" checked onchange="toggleViewMode()" style="margin: 0;">
                                <span>üìã List</span>
                            </label>
                            <label class="view-mode-radio" style="display: flex; align-items: center; gap: 4px; cursor: pointer; padding: 6px 12px; border-radius: 6px; transition: all 0.2s; background-color: #f9fafb; border: 1px solid #e5e7eb;">
                                <input type="radio" name="viewMode" value="tabs" onchange="toggleViewMode()" style="margin: 0;">
                                <span>üóÇÔ∏è Tabs</span>
                            </label>
                        </div>
                    </div>
                </div>
                <div style="font-size: 11px; color: #9ca3af; font-weight: normal;">
                    Phillip's Task Automation
                </div>
            </div>
            <!-- Task List View (hidden by default) -->
            <div id="tasksList" class="tasks-list" style="display: none;">
                <!-- Select All Controls -->
                <div class="select-all-container">
                    <input type="checkbox" id="selectAllTasks" class="task-checkbox" onchange="toggleSelectAll()">
                    <label for="selectAllTasks">Select All Tasks</label>
                </div>

                <!-- Batch Action Toolbar -->
                <div id="batchToolbar" class="batch-selection-toolbar">
                    <div class="batch-selection-info">
                        <span id="selectedCount">0</span> task(s) selected
                    </div>
                    <div class="batch-actions">
                        <button onclick="batchStartTasks()" class="btn btn-success btn-sm">üöÄ Start</button>
                        <button onclick="batchDeleteTasks()" class="btn btn-danger btn-sm">üóëÔ∏è Delete Task</button>
                        <button onclick="batchClearAndRestartTasks()" class="btn btn-warning btn-sm">üîÑ Clear & Restart</button>
                        <button onclick="batchRefreshTasks()" class="btn btn-sm">üîÑ Refresh</button>
                        <button onclick="clearSelection()" class="btn btn-sm">‚úñÔ∏è Clear Selection</button>
                    </div>
                </div>

                <!-- Container for task items -->
                <div id="tasksContainer">
                    <div class="loading">Loading tasks...</div>
                </div>
            </div>

            <!-- Task Tab View (default) -->
            <div id="tasksTabView" class="tasks-tab-view">
                <div class="tab-container">
                    <div id="taskTabs" class="task-tabs">
                        <!-- Task tabs will be dynamically generated here -->
                    </div>
                    <div id="taskContent" class="task-content">
                        <div class="conversation-nav-container">
                            <div class="conversation-content">
                                <div class="no-task-selected">
                                    Select a task tab to view its conversation
                                </div>
                            </div>
                            <div id="conversationNavSidebar" class="conversation-nav-sidebar">
                                <!-- Navigation indicators will be generated here -->
                            </div>
                        </div>
                    </div>
                    <!-- Fixed Input Box for Tabs View -->
                    <div class="fixed-tab-input">
                        <div style="display: flex; gap: 6px;">
                            <input type="text" id="tabMessageInput" placeholder="Type your message here..." style="flex: 1; padding: 4px 6px; border: 1px solid #ddd; border-radius: 4px;">
                            <button class="btn btn-primary" style="padding: 4px 12px;">Send</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Directory Browser Modal -->
    <div id="directoryModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìÅ Browse Directories</h2>
                <button class="modal-close" onclick="closeDirectoryModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="dir-browser">
                    <div class="dir-path">
                        <span id="currentPath" style="flex: 1;"></span>
                        <button onclick="goToParent()" class="btn btn-sm" id="parentBtn">‚¨ÜÔ∏è Up</button>
                    </div>
                    <ul class="dir-list" id="dirList">
                        <li class="loading" style="padding: 20px; text-align: center;">Loading...</li>
                    </ul>
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="selectCurrentDirectory()" class="btn btn-success btn-sm">‚úì Select This Folder</button>
                <button onclick="closeDirectoryModal()" class="btn btn-sm">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Conversation Modal -->
    <div id="conversationModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üó®Ô∏è Task Conversation</h2>
                <div style="display: flex; gap: 10px;">
                    <button class="modal-close" onclick="closeConversationModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <div class="conversation-nav-container">
                    <div class="conversation-content">
                        <div id="conversationContent" class="conversation">
                            <div class="loading">Loading conversation...</div>
                        </div>
                    </div>
                    <div id="conversationNavSidebarModal" class="conversation-nav-sidebar">
                        <div class="conversation-minimap" id="conversationMinimapModal">
                            <div class="conversation-viewport-indicator" id="viewportIndicatorModal"></div>
                        </div>
                    </div>
                </div>
                <div class="message-input-box">
                    <div class="input-header">
                        üí¨ Send Message
                        <button type="button" onclick="openPromptLibrary('messageInput')" class="btn btn-sm" style="float: right; margin-left: 10px;" title="Load from prompt library">
                            üìö Load Prompt
                        </button>
                        <button type="button" onclick="saveCurrentPrompt('messageInput')" class="btn btn-sm" style="float: right;" title="Save current text as prompt">
                            üíæ Save as Prompt
                        </button>
                    </div>
                    <div class="input-container">
                        <input type="text" id="messageInput" placeholder="Type your message and press Enter to send..." onkeypress="handleMessageKeyPress(event)">
                        <button onclick="sendMessage()" class="btn btn-success btn-sm send-btn">Send</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="refreshConversation()" class="btn btn-sm">üîÑ Refresh</button>
                <button onclick="closeConversationModal()" class="btn btn-sm">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Task Modal -->
    <div id="editTaskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚úèÔ∏è Edit Task</h2>
                <button class="modal-close" onclick="closeEditModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="editAlert"></div>
                <form id="editTaskForm">
                    <input type="hidden" id="editTaskName">
                    <div class="form-group">
                        <label for="editDescription">Description *
                            <button type="button" onclick="saveToPromptLibrary('editDescription')" class="btn btn-sm" style="float: right; margin-left: 5px;" title="Save to prompt library">
                                üíæ
                            </button>
                            <button type="button" onclick="openPromptLibrary('editDescription')" class="btn btn-sm" style="float: right;" title="Load from prompt library">
                                üìö
                            </button>
                        </label>
                        <textarea id="editDescription" placeholder="Describe what Claude should implement..." required></textarea>
                    </div>
                    <div class="form-group">
                        <label>Projects Configuration *</label>


                        <div id="editProjectsList" style="border: 2px solid #e0e0e0; border-radius: 6px; padding: 15px; min-height: 80px; background: #f3f4f6;">
                            <!-- Projects will be displayed here -->
                        </div>
                        <small style="color: #6b7280; font-size: 12px; margin-top: 4px; display: block;">Configure projects for this task. Changes will be saved when you update the task.</small>
                    </div>
                    <div class="form-group">
                        <label for="editEndCriteria">End Criteria
                            <button type="button" onclick="saveToPromptLibrary('editEndCriteria')" class="btn btn-sm" style="float: right; margin-left: 5px;" title="Save to prompt library">
                                üíæ
                            </button>
                            <button type="button" onclick="openPromptLibrary('editEndCriteria')" class="btn btn-sm" style="float: right;" title="Load from prompt library">
                                üìö
                            </button>
                        </label>
                        <textarea id="editEndCriteria" placeholder="Describe how Claude should know when the task is complete..." rows="3"></textarea>
                        <small style="color: #6b7280; font-size: 12px; margin-top: 4px; display: block;">Conditions that indicate task completion</small>
                    </div>
                    <div class="form-group">
                        <label for="editMaxIterations">Max Iterations</label>
                        <input type="number" id="editMaxIterations" placeholder="20" min="1" max="100">
                        <small style="color: #6b7280; font-size: 12px; margin-top: 4px; display: block;">Maximum number of conversation rounds (default: 20)</small>
                    </div>
                    <div class="form-group">
                        <label for="editMaxTokens">Max Tokens</label>
                        <input type="number" id="editMaxTokens" placeholder="100000" min="1000" step="1000">
                        <small style="color: #6b7280; font-size: 12px; margin-top: 4px; display: block;">Maximum total tokens to use for this task</small>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button onclick="closeEditModal()" class="btn btn-sm">Cancel</button>
                <button onclick="saveTaskEdit()" class="btn btn-success">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Prompt Library Modal -->
    <div id="promptLibraryModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>üìö Prompt Library</h2>
                <button class="modal-close" onclick="closePromptLibrary()">&times;</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px; display: flex; gap: 10px;">
                    <input type="text" id="promptSearch" placeholder="Search prompts..." style="flex: 1;" onkeyup="searchPrompts()">
                    <select id="promptCategoryFilter" onchange="filterPrompts()" style="width: 150px;">
                        <option value="">All Categories</option>
                        <option value="task">Task</option>
                        <option value="bug-fix">Bug Fix</option>
                        <option value="feature">Feature</option>
                        <option value="refactor">Refactor</option>
                        <option value="test">Test</option>
                        <option value="docs">Documentation</option>
                        <option value="other">Other</option>
                    </select>
                    <button onclick="loadPrompts()" class="btn btn-sm">üîÑ Refresh</button>
                </div>
                <div id="promptList" class="prompt-list">
                    <div class="loading">Loading prompts...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="closePromptLibrary()" class="btn btn-sm">Close</button>
            </div>
        </div>
    </div>

    <!-- Save Prompt Modal -->
    <div id="savePromptModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üíæ Save Prompt</h2>
                <button class="modal-close" onclick="closeSavePrompt()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="savePromptForm">
                    <div class="form-group">
                        <label for="promptTitle">Prompt Title *</label>
                        <input type="text" id="promptTitle" placeholder="e.g., Add REST API endpoint" required>
                    </div>
                    <div class="form-group">
                        <label for="promptCategory">Category</label>
                        <select id="promptCategory">
                            <option value="">None</option>
                            <option value="task">Task</option>
                            <option value="bug-fix">Bug Fix</option>
                            <option value="feature">Feature</option>
                            <option value="refactor">Refactor</option>
                            <option value="test">Test</option>
                            <option value="docs">Documentation</option>
                            <option value="other">Other</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="promptTags">Tags (comma-separated)</label>
                        <input type="text" id="promptTags" placeholder="e.g., api, rest, backend">
                    </div>
                    <div class="form-group">
                        <label for="promptContent">Content *</label>
                        <textarea id="promptContent" rows="10" required></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button onclick="savePromptToLibrary()" class="btn btn-success btn-sm">üíæ Save</button>
                <button onclick="closeSavePrompt()" class="btn btn-sm">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Edit Prompt Modal -->
    <div id="editPromptModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚úèÔ∏è Edit Prompt</h2>
                <button class="modal-close" onclick="closeEditPrompt()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="editPromptForm">
                    <input type="hidden" id="editPromptId">
                    <div class="form-group">
                        <label for="editPromptTitle">Prompt Title *</label>
                        <input type="text" id="editPromptTitle" placeholder="e.g., Add REST API endpoint" required>
                    </div>
                    <div class="form-group">
                        <label for="editPromptCategory">Category</label>
                        <select id="editPromptCategory">
                            <option value="">None</option>
                            <option value="task">Task</option>
                            <option value="bug-fix">Bug Fix</option>
                            <option value="feature">Feature</option>
                            <option value="refactor">Refactor</option>
                            <option value="test">Test</option>
                            <option value="docs">Documentation</option>
                            <option value="other">Other</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="editPromptTags">Tags (comma-separated)</label>
                        <input type="text" id="editPromptTags" placeholder="e.g., api, rest, backend">
                    </div>
                    <div class="form-group">
                        <label for="editPromptContent">Content *</label>
                        <textarea id="editPromptContent" rows="10" required></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button onclick="updatePrompt()" class="btn btn-success btn-sm">üíæ Update</button>
                <button onclick="deletePrompt()" class="btn btn-danger btn-sm">üóëÔ∏è Delete</button>
                <button onclick="closeEditPrompt()" class="btn btn-sm">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Project Template Selection Modal -->
    <div id="projectTemplateModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>üìÇ Select Project Template</h2>
                <span onclick="closeProjectTemplateModal()" class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <label for="templateSelect">Choose a project template:</label>
                <select id="templateSelect" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 6px;">
                </select>
            </div>
            <div class="modal-footer">
                <button onclick="loadSelectedTemplate()" class="btn btn-success btn-sm">üìÇ Load Template</button>
                <button onclick="closeProjectTemplateModal()" class="btn btn-sm">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = '/api/v1';
        let currentTaskName = null;

        // Toggle create task form visibility
        function toggleCreateForm() {
            const createCard = document.getElementById('createTaskCard');
            if (createCard.style.display === 'none') {
                createCard.style.display = 'block';
                // Scroll to the form
                createCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                createCard.style.display = 'none';
            }
        }

        // ============================================
        // Saved Projects Management (Database)
        // ============================================
        let savedProjects = [];
        const DEFAULT_USER_ID = 'default_user';

        function toggleProjectsPanel() {
            const panel = document.getElementById('projectsPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                loadSavedProjects();
                panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                panel.style.display = 'none';
            }
        }

        async function loadSavedProjects() {
            try {
                const response = await fetch(`${API_BASE}/projects?user_id=${DEFAULT_USER_ID}`);
                if (response.ok) {
                    savedProjects = await response.json();
                    renderSavedProjectsTable();
                }
            } catch (error) {
                console.error('Failed to load saved projects:', error);
                showProjectsAlert('Failed to load projects', 'error');
            }
        }

        function renderSavedProjectsTable() {
            const tbody = document.getElementById('savedProjectsTableBody');
            if (savedProjects.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="padding: 20px; text-align: center; color: #6b7280;">No saved projects. Add one above.</td></tr>';
                return;
            }

            tbody.innerHTML = savedProjects.map(project => `
                <tr style="border-bottom: 1px solid #e5e7eb;">
                    <td style="padding: 10px; font-weight: 500;">${project.name}</td>
                    <td style="padding: 10px; font-family: monospace; font-size: 12px;">${project.path}</td>
                    <td style="padding: 10px;">
                        <span style="padding: 2px 8px; border-radius: 4px; font-size: 12px; background: ${project.default_access === 'write' ? '#dbeafe' : '#dcfce7'}; color: ${project.default_access === 'write' ? '#1d4ed8' : '#166534'};">
                            ${project.default_access}
                        </span>
                    </td>
                    <td style="padding: 10px; color: #6b7280;">${project.default_branch || '-'}</td>
                    <td style="padding: 10px;">
                        <button onclick="addSavedProjectToTask('${project.id}')" class="btn btn-sm btn-success" style="padding: 4px 8px; font-size: 11px;" title="Add to current task">
                            ‚ûï Add to Task
                        </button>
                        <button onclick="deleteSavedProject('${project.id}')" class="btn btn-sm btn-danger" style="padding: 4px 8px; font-size: 11px; margin-left: 4px;" title="Delete project">
                            üóëÔ∏è
                        </button>
                    </td>
                </tr>
            `).join('');
        }

        async function createSavedProject() {
            const name = document.getElementById('newProjectName').value.trim();
            const path = document.getElementById('newProjectPath').value.trim();
            const access = document.getElementById('newProjectAccess').value;
            const branch = document.getElementById('newProjectBranch').value.trim();
            const context = document.getElementById('newProjectContext').value.trim();

            if (!name || !path) {
                showProjectsAlert('Name and Path are required', 'error');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/projects`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name,
                        path,
                        user_id: DEFAULT_USER_ID,
                        default_access: access,
                        default_branch: branch || null,
                        default_context: context || null
                    })
                });

                if (response.ok) {
                    // Clear form
                    document.getElementById('newProjectName').value = '';
                    document.getElementById('newProjectPath').value = '';
                    document.getElementById('newProjectBranch').value = '';
                    document.getElementById('newProjectContext').value = '';
                    document.getElementById('newProjectAccess').value = 'write';

                    showProjectsAlert('Project saved successfully!', 'success');
                    await loadSavedProjects();
                } else {
                    const error = await response.json();
                    showProjectsAlert(error.detail || 'Failed to create project', 'error');
                }
            } catch (error) {
                console.error('Failed to create project:', error);
                showProjectsAlert('Failed to create project', 'error');
            }
        }

        async function deleteSavedProject(projectId) {
            if (!confirm('Delete this saved project?')) return;

            try {
                const response = await fetch(`${API_BASE}/projects/${projectId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    showProjectsAlert('Project deleted', 'success');
                    await loadSavedProjects();
                } else {
                    showProjectsAlert('Failed to delete project', 'error');
                }
            } catch (error) {
                console.error('Failed to delete project:', error);
                showProjectsAlert('Failed to delete project', 'error');
            }
        }

        function addSavedProjectToTask(projectId) {
            const project = savedProjects.find(p => p.id === projectId);
            if (!project) return;

            // Add to the task creation form's project list
            projectsData.push({
                name: project.name,
                path: project.path,
                access: project.default_access,
                context: project.default_context || '',
                branch_name: project.default_branch || ''
            });
            renderProjectsList();

            // Show the create form if hidden
            const createCard = document.getElementById('createTaskCard');
            if (createCard.style.display === 'none') {
                createCard.style.display = 'block';
            }

            showProjectsAlert(`Added "${project.name}" to task`, 'success');
        }

        function showProjectsAlert(message, type) {
            const alertDiv = document.getElementById('projectsAlert');
            alertDiv.innerHTML = `
                <div style="padding: 10px; margin-bottom: 15px; border-radius: 6px; background: ${type === 'error' ? '#fee2e2' : '#dcfce7'}; color: ${type === 'error' ? '#991b1b' : '#166534'};">
                    ${message}
                </div>
            `;
            setTimeout(() => { alertDiv.innerHTML = ''; }, 3000);
        }

        // Project management state
        let projectsData = [];

        // Project templates state
        let projectTemplates = {};

        // Individual project templates state
        let individualProjectTemplates = {};

        // Load projects list on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize with empty projects list
            renderProjectsList();
            // Load project templates from localStorage
            loadProjectTemplates();
            loadIndividualProjectTemplates();
            // Initialize view mode to ensure correct state
            toggleViewMode();
        });

        // Directory browser state
        let currentBrowsePath = null;

        // Project Management Functions
        function addProject() {
            const newProject = {
                name: '',
                path: '',
                access: 'write',
                context: '',
                branch_name: ''
            };
            projectsData.push(newProject);
            renderProjectsList();
        }

        function removeProject(index) {
            projectsData.splice(index, 1);
            renderProjectsList();
        }

        function renderProjectsList() {
            const container = document.getElementById('projectsList');

            if (projectsData.length === 0) {
                container.innerHTML = '<div class="projects-empty">No projects configured. Click "Add Project" to get started.</div>';
                return;
            }

            let html = '';
            projectsData.forEach((project, index) => {
                html += `
                    <div class="project-item">
                        <div class="project-header">
                            <div class="project-title">${project.name || `Project ${index + 1}`}</div>
                            <div style="display: flex; gap: 6px;">
                                <button type="button" onclick="saveIndividualProject(${index})" class="btn btn-sm" style="background: #10b981; color: white; padding: 3px 6px; font-size: 11px;" title="Save this project as template">
                                    üíæ
                                </button>
                                <button type="button" onclick="loadIndividualProject(${index})" class="btn btn-sm" style="background: #3b82f6; color: white; padding: 3px 6px; font-size: 11px;" title="Load project template">
                                    üìÇ
                                </button>
                                <button type="button" class="project-remove" onclick="removeProject(${index})">‚úï Remove</button>
                            </div>
                        </div>
                        <div class="project-fields">
                            <div class="project-field">
                                <label>Project Name</label>
                                <input type="text" placeholder="My Project" value="${project.name || ''}"
                                       onchange="updateProject(${index}, 'name', this.value)"
                                       style="width: 100%;">
                            </div>
                            <div class="project-field">
                                <label>Project Path *</label>
                                <div style="display: flex; gap: 8px;">
                                    <input type="text" placeholder="/path/to/project" value="${project.path}"
                                           onchange="updateProject(${index}, 'path', this.value)" required
                                           style="flex: 1;" id="project-path-${index}">
                                    <button type="button" onclick="browseForFolder(${index})" class="btn btn-sm"
                                            style="white-space: nowrap;" title="Browse for folder">
                                        üìÅ Browse
                                    </button>
                                </div>
                            </div>
                            <div class="project-field">
                                <label>Access</label>
                                <select onchange="updateProject(${index}, 'access', this.value)">
                                    <option value="write" ${project.access === 'write' ? 'selected' : ''}>Write</option>
                                    <option value="read" ${project.access === 'read' ? 'selected' : ''}>Read</option>
                                </select>
                            </div>
                            <div class="project-field">
                                <label>Base Branch
                                    <button type="button" onclick="loadProjectBranches(${index})" class="btn btn-sm" style="float: right; font-size: 11px; padding: 2px 6px;" title="Load branches from this project">
                                        üîÑ
                                    </button>
                                </label>
                                <select id="project-base-branch-${index}" onchange="updateProject(${index}, 'base_branch', this.value)">
                                    <option value="">Auto-detect current branch</option>
                                    ${project.base_branch ? `<option value="${project.base_branch}" selected>${project.base_branch}</option>` : ''}
                                </select>
                            </div>
                            <div class="project-field">
                                <label>Task Branch</label>
                                <input type="text" placeholder="feature/task-name" value="${project.branch_name || ''}"
                                       onchange="updateProject(${index}, 'branch_name', this.value)">
                            </div>
                        </div>
                        <div class="project-field" style="margin-top: 10px;">
                            <label>Context Description</label>
                            <input type="text" placeholder="Describe this project's role in the task..." value="${project.context || ''}"
                                   onchange="updateProject(${index}, 'context', this.value)" style="width: 100%;">
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function updateProject(index, field, value) {
            if (projectsData[index]) {
                projectsData[index][field] = value;
            }
        }

        // Project Template Management Functions
        function loadProjectTemplates() {
            try {
                const saved = localStorage.getItem('claudeProjectTemplates');
                if (saved) {
                    projectTemplates = JSON.parse(saved);
                    renderProjectTemplateOptions();
                }
            } catch (error) {
                console.error('Error loading project templates:', error);
                projectTemplates = {};
            }
        }

        function saveProjectTemplates() {
            try {
                localStorage.setItem('claudeProjectTemplates', JSON.stringify(projectTemplates));
            } catch (error) {
                console.error('Error saving project templates:', error);
                alert('Failed to save project templates to local storage');
            }
        }

        function renderProjectTemplateOptions() {
            const select = document.getElementById('projectTemplateSelect');
            if (!select) return;

            // Clear existing options except the first one
            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }

            // Add template options
            Object.keys(projectTemplates).forEach(templateName => {
                const option = document.createElement('option');
                option.value = templateName;
                option.textContent = templateName;
                select.appendChild(option);
            });
        }

        function saveCurrentProjectsAsTemplate() {
            if (projectsData.length === 0) {
                alert('No projects configured to save as template');
                return;
            }

            const templateName = prompt('Enter a name for this project template:');
            if (!templateName || templateName.trim() === '') {
                return;
            }

            const cleanName = templateName.trim();

            // Create a deep copy of current projects data
            const template = JSON.parse(JSON.stringify(projectsData));

            projectTemplates[cleanName] = template;
            saveProjectTemplates();
            renderProjectTemplateOptions();

            alert(`Project template "${cleanName}" saved successfully!`);
        }

        function loadProjectTemplate() {
            const select = document.getElementById('projectTemplateSelect');
            const templateName = select.value;

            if (!templateName) {
                alert('Please select a template to load');
                return;
            }

            if (!projectTemplates[templateName]) {
                alert('Template not found');
                return;
            }

            // Confirm if there are existing projects
            if (projectsData.length > 0) {
                if (!confirm('This will replace your current project configuration. Continue?')) {
                    return;
                }
            }

            // Load the template
            projectsData = JSON.parse(JSON.stringify(projectTemplates[templateName]));
            renderProjectsList();

            alert(`Project template "${templateName}" loaded successfully!`);
        }

        async function deleteProjectTemplate(event) {
            const select = document.getElementById('projectTemplateSelect');
            const templateName = select.value;

            if (!templateName) {
                alert('Please select a template to delete');
                return;
            }

            const confirmed = await showCustomConfirm(`Are you sure you want to delete the template "${templateName}"?`, event.target);
            if (!confirmed) {
                return;
            }

            delete projectTemplates[templateName];
            saveProjectTemplates();
            renderProjectTemplateOptions();

            // Reset selection
            select.value = '';

            alert(`Project template "${templateName}" deleted successfully!`);
        }

        // Individual Project Template Functions
        function loadIndividualProjectTemplates() {
            try {
                const saved = localStorage.getItem('claudeIndividualProjectTemplates');
                if (saved) {
                    individualProjectTemplates = JSON.parse(saved);
                }
            } catch (error) {
                console.error('Error loading individual project templates:', error);
                individualProjectTemplates = {};
            }
        }

        function saveIndividualProjectTemplates() {
            try {
                localStorage.setItem('claudeIndividualProjectTemplates', JSON.stringify(individualProjectTemplates));
            } catch (error) {
                console.error('Error saving individual project templates:', error);
                alert('Failed to save project templates to local storage');
            }
        }

        function saveIndividualProject(projectIndex) {
            const project = projectsData[projectIndex];
            if (!project) {
                alert('Project not found');
                return;
            }

            if (!project.path || project.path.trim() === '') {
                alert('Please enter a project path before saving');
                return;
            }

            // Use project name if provided, otherwise ask for one
            let projectName = project.name && project.name.trim() !== '' ? project.name.trim() : null;

            if (!projectName) {
                projectName = prompt('Enter a name for this project template:');
                if (!projectName || projectName.trim() === '') {
                    return;
                }
                projectName = projectName.trim();
            }

            const cleanName = projectName;

            // Check if template already exists and warn user
            if (individualProjectTemplates[cleanName]) {
                // Find the Save Template button
                const triggerButton = document.querySelector(`button[onclick="saveIndividualProject(${projectIndex})"]`) ||
                                    document.querySelector('.save-template-btn') ||
                                    event?.target;

                showPositionedConfirm(
                    `A project template named "${cleanName}" already exists. Do you want to replace it?`,
                    triggerButton,
                    function(confirmed) {
                        if (confirmed) {
                            // Create a deep copy of the current project
                            const template = JSON.parse(JSON.stringify(project));

                            individualProjectTemplates[cleanName] = template;
                            saveIndividualProjectTemplates();

                            alert(`Project "${cleanName}" saved successfully!`);
                        }
                    }
                );
                return;
            }

            // Create a deep copy of the current project
            const template = JSON.parse(JSON.stringify(project));

            individualProjectTemplates[cleanName] = template;
            saveIndividualProjectTemplates();

            alert(`Project "${cleanName}" saved successfully!`);
        }

        // Variable to store current project index for template loading
        let currentProjectIndexForTemplate = null;

        // Custom positioned confirmation dialog system
        function showPositionedConfirm(message, triggerElement, callback) {
            // Remove any existing confirmation dialog
            const existingDialog = document.getElementById('positioned-confirm-dialog');
            if (existingDialog) {
                existingDialog.remove();
            }

            // Create confirmation dialog
            const dialog = document.createElement('div');
            dialog.id = 'positioned-confirm-dialog';
            dialog.style.cssText = `
                position: fixed;
                background: white;
                border: 1px solid #d1d5db;
                border-radius: 8px;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
                padding: 16px;
                z-index: 10000;
                max-width: 300px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 14px;
                line-height: 1.5;
            `;

            // Create message
            const messageDiv = document.createElement('div');
            messageDiv.textContent = message;
            messageDiv.style.cssText = `
                margin-bottom: 16px;
                color: #374151;
            `;

            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                gap: 8px;
                justify-content: flex-end;
            `;

            // Create Cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = `
                padding: 6px 12px;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                background: white;
                color: #374151;
                cursor: pointer;
                font-size: 13px;
            `;
            cancelBtn.addEventListener('mouseover', function() {
                this.style.background = '#f9fafb';
            });
            cancelBtn.addEventListener('mouseout', function() {
                this.style.background = 'white';
            });

            // Create Confirm button
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'OK';
            confirmBtn.style.cssText = `
                padding: 6px 12px;
                border: 1px solid #3b82f6;
                border-radius: 4px;
                background: #3b82f6;
                color: white;
                cursor: pointer;
                font-size: 13px;
            `;
            confirmBtn.addEventListener('mouseover', function() {
                this.style.background = '#2563eb';
            });
            confirmBtn.addEventListener('mouseout', function() {
                this.style.background = '#3b82f6';
            });

            // Add click handlers
            cancelBtn.addEventListener('click', function() {
                dialog.remove();
                callback(false);
            });
            confirmBtn.addEventListener('click', function() {
                dialog.remove();
                callback(true);
            });

            // Assemble dialog
            buttonContainer.appendChild(cancelBtn);
            buttonContainer.appendChild(confirmBtn);
            dialog.appendChild(messageDiv);
            dialog.appendChild(buttonContainer);
            document.body.appendChild(dialog);

            // Position dialog near the trigger element
            if (triggerElement) {
                const triggerRect = triggerElement.getBoundingClientRect();

                // Get actual dialog dimensions after it's added to DOM
                const dialogRect = dialog.getBoundingClientRect();
                const dialogWidth = dialogRect.width || 300; // fallback to max-width
                const dialogHeight = dialogRect.height || 150; // measured height

                // Try to position below and to the right of the button
                let left = triggerRect.left;
                let top = triggerRect.bottom + 8;

                // Adjust if dialog would go off-screen
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                // Horizontal positioning
                if (left + dialogWidth > viewportWidth) {
                    left = viewportWidth - dialogWidth - 16;
                }
                if (left < 16) {
                    left = 16;
                }

                // Vertical positioning - ensure dialog is fully visible
                if (top + dialogHeight > viewportHeight) {
                    // Try positioning above the button
                    top = triggerRect.top - dialogHeight - 8;
                }
                // If still not fitting above, place it at the top with margin
                if (top < 16) {
                    top = 16;
                }
                // Final check: if dialog is too tall for viewport, position at top
                if (top + dialogHeight > viewportHeight) {
                    top = Math.max(16, viewportHeight - dialogHeight - 16);
                }

                dialog.style.left = left + 'px';
                dialog.style.top = top + 'px';
            } else {
                // Fallback to center if no trigger element
                dialog.style.left = '50%';
                dialog.style.top = '50%';
                dialog.style.transform = 'translate(-50%, -50%)';
            }

            // Focus the confirm button for keyboard navigation
            confirmBtn.focus();

            // Handle Escape key
            const escapeHandler = function(e) {
                if (e.key === 'Escape') {
                    dialog.remove();
                    document.removeEventListener('keydown', escapeHandler);
                    callback(false);
                }
            };
            document.addEventListener('keydown', escapeHandler);

            // Handle Enter key
            const enterHandler = function(e) {
                if (e.key === 'Enter') {
                    dialog.remove();
                    document.removeEventListener('keydown', enterHandler);
                    document.removeEventListener('keydown', escapeHandler);
                    callback(true);
                }
            };
            document.addEventListener('keydown', enterHandler);
        }

        // Promise-based wrapper for showPositionedConfirm
        function showCustomConfirm(message, triggerElement) {
            return new Promise((resolve) => {
                showPositionedConfirm(message, triggerElement, (result) => {
                    resolve(result);
                });
            });
        }

        function showToast(message, type = 'success', duration = 4000) {
            // Create toast container if it doesn't exist
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 10000;
                    pointer-events: none;
                `;
                document.body.appendChild(toastContainer);
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.style.cssText = `
                background: ${type === 'success' ? '#28a745' : '#dc3545'};
                color: white;
                padding: 12px 20px;
                margin-bottom: 10px;
                border-radius: 4px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                font-size: 14px;
                line-height: 1.4;
                max-width: 350px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
                pointer-events: auto;
                white-space: pre-line;
            `;
            toast.textContent = message;

            toastContainer.appendChild(toast);

            // Animate in
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(0)';
            }, 10);

            // Auto remove
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, duration);
        }

        function loadIndividualProject(projectIndex) {
            const templates = Object.keys(individualProjectTemplates);
            if (templates.length === 0) {
                alert('No saved project templates found. Save a project first.');
                return;
            }

            // Store the project index for use in the modal
            currentProjectIndexForTemplate = projectIndex;

            // Populate the dropdown with available templates
            const templateSelect = document.getElementById('templateSelect');
            templateSelect.innerHTML = '';

            templates.forEach(templateName => {
                const option = document.createElement('option');
                option.value = templateName;
                option.textContent = templateName;
                templateSelect.appendChild(option);
            });

            // Show the modal
            document.getElementById('projectTemplateModal').classList.add('show');
        }

        function closeProjectTemplateModal() {
            document.getElementById('projectTemplateModal').classList.remove('show');
            currentProjectIndexForTemplate = null;
        }

        function loadSelectedTemplate() {
            const templateSelect = document.getElementById('templateSelect');
            const selectedTemplate = templateSelect.value;

            if (!selectedTemplate) {
                alert('Please select a template');
                return;
            }

            const template = individualProjectTemplates[selectedTemplate];
            if (!template) {
                alert('Template not found');
                return;
            }

            // Find the triggering button (Load Template button)
            const triggerButton = document.querySelector('.template-actions .load-btn') ||
                                document.querySelector('button[onclick*="loadIndividualProject"]');

            showPositionedConfirm(
                `This will replace the current project configuration. Continue?`,
                triggerButton,
                function(confirmed) {
                    if (confirmed) {
                        // Check if we're in edit mode or create mode
                        if (typeof editProjectsData !== 'undefined' && editProjectsData && editProjectsData.length > 0) {
                            // Edit mode - load into editProjectsData
                            editProjectsData[currentProjectIndexForTemplate] = JSON.parse(JSON.stringify(template));
                            renderEditProjectsConfiguration();
                        } else {
                            // Create mode - load into projectsData
                            projectsData[currentProjectIndexForTemplate] = JSON.parse(JSON.stringify(template));
                            renderProjectsList();
                        }

                        closeProjectTemplateModal();
                        alert(`Project template "${selectedTemplate}" loaded successfully!`);
                    }
                }
            );
        }

        function saveEditIndividualProject(projectIndex) {
            const project = editProjectsData[projectIndex];
            if (!project) {
                alert('Project not found');
                return;
            }

            if (!project.path || project.path.trim() === '') {
                alert('Please enter a project path before saving');
                return;
            }

            // Use the project name from the form field
            const projectName = project.name || '';
            if (!projectName || projectName.trim() === '') {
                alert('Please enter a project name before saving');
                return;
            }

            const cleanName = projectName.trim();

            // Check if template already exists and warn user
            if (individualProjectTemplates[cleanName]) {
                // Find the Save Template button for edit mode
                const triggerButton = document.querySelector(`button[onclick="saveEditIndividualProject(${projectIndex})"]`) ||
                                    document.querySelector('.save-edit-template-btn') ||
                                    event?.target;

                showPositionedConfirm(
                    `A project template named "${cleanName}" already exists. Do you want to replace it?`,
                    triggerButton,
                    function(confirmed) {
                        if (confirmed) {
                            // Create a deep copy of the current project
                            const template = JSON.parse(JSON.stringify(project));

                            individualProjectTemplates[cleanName] = template;
                            saveIndividualProjectTemplates();

                            alert(`Project "${cleanName}" saved successfully!`);
                        }
                    }
                );
                return;
            }

            // Create a deep copy of the current project
            const template = JSON.parse(JSON.stringify(project));

            individualProjectTemplates[cleanName] = template;
            saveIndividualProjectTemplates();

            alert(`Project "${cleanName}" saved successfully!`);
        }

        function loadEditIndividualProject(projectIndex) {
            const templates = Object.keys(individualProjectTemplates);
            if (templates.length === 0) {
                alert('No saved project templates found. Save a project first.');
                return;
            }

            // Store the project index for use in the modal
            currentProjectIndexForTemplate = projectIndex;

            // Populate the dropdown with available templates
            const templateSelect = document.getElementById('templateSelect');
            templateSelect.innerHTML = '';

            templates.forEach(templateName => {
                const option = document.createElement('option');
                option.value = templateName;
                option.textContent = templateName;
                templateSelect.appendChild(option);
            });

            // Show the modal
            document.getElementById('projectTemplateModal').classList.add('show');
        }

        // Edit Modal Template Functions
        function saveCurrentEditProjectsAsTemplate() {
            if (editProjectsData.length === 0) {
                alert('No projects configured to save as template');
                return;
            }

            const templateName = prompt('Enter a name for this project template:');
            if (!templateName || templateName.trim() === '') {
                return;
            }

            const cleanName = templateName.trim();

            // Create a deep copy of current edit projects data
            const template = JSON.parse(JSON.stringify(editProjectsData));

            projectTemplates[cleanName] = template;
            saveProjectTemplates();
            renderProjectTemplateOptions();
            renderEditProjectTemplateOptions();

            alert(`Project template "${cleanName}" saved successfully!`);
        }

        function loadEditProjectTemplate() {
            const select = document.getElementById('editProjectTemplateSelect');
            const templateName = select.value;

            if (!templateName) {
                alert('Please select a template to load');
                return;
            }

            if (!projectTemplates[templateName]) {
                alert('Template not found');
                return;
            }

            // Confirm if there are existing projects
            if (editProjectsData.length > 0) {
                if (!confirm('This will replace your current project configuration. Continue?')) {
                    return;
                }
            }

            // Load the template
            editProjectsData = JSON.parse(JSON.stringify(projectTemplates[templateName]));
            renderEditProjectsConfiguration();

            alert(`Project template "${templateName}" loaded successfully!`);
        }

        function deleteEditProjectTemplate() {
            const select = document.getElementById('editProjectTemplateSelect');
            const templateName = select.value;

            if (!templateName) {
                alert('Please select a template to delete');
                return;
            }

            if (!confirm(`Are you sure you want to delete the template "${templateName}"?`)) {
                return;
            }

            delete projectTemplates[templateName];
            saveProjectTemplates();
            renderProjectTemplateOptions();
            renderEditProjectTemplateOptions();

            // Reset selection
            select.value = '';

            alert(`Project template "${templateName}" deleted successfully!`);
        }

        function renderEditProjectTemplateOptions() {
            const select = document.getElementById('editProjectTemplateSelect');
            if (!select) return;

            // Clear existing options except the first one
            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }

            // Add template options
            Object.keys(projectTemplates).forEach(templateName => {
                const option = document.createElement('option');
                option.value = templateName;
                option.textContent = templateName;
                select.appendChild(option);
            });
        }

        // Global variable to store edit projects data
        let editProjectsData = [];

        function setupEditProjectsConfiguration(projects) {
            // Initialize edit projects data
            editProjectsData = projects.length > 0 ? [...projects] : [{
                path: '',
                access: 'write',
                context: '',
                base_branch: '',
                branch_name: ''
            }];

            renderEditProjectsConfiguration();
            renderEditProjectTemplateOptions();
        }

        function renderEditProjectsConfiguration() {
            const container = document.getElementById('editProjectsList');

            let html = '';
            editProjectsData.forEach((project, index) => {
                html += `
                    <div style="border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px; margin-bottom: 12px; background: white;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <div style="font-weight: 600; color: #374151; font-size: 14px;">Project ${index + 1}</div>
                            <div style="display: flex; gap: 6px;">
                                <button type="button" onclick="saveEditIndividualProject(${index})" style="background: #10b981; color: white; border: none; padding: 3px 6px; border-radius: 3px; font-size: 11px; cursor: pointer;" title="Save this project">
                                    üíæ
                                </button>
                                <button type="button" onclick="loadEditIndividualProject(${index})" style="background: #3b82f6; color: white; border: none; padding: 3px 6px; border-radius: 3px; font-size: 11px; cursor: pointer;" title="Load project template">
                                    üìÇ
                                </button>
                                ${editProjectsData.length > 1 ? `<button type="button" onclick="removeEditProject(${index})" style="background: #ef4444; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; cursor: pointer;">Remove</button>` : ''}
                            </div>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <div class="project-field">
                                <label style="display: block; margin-bottom: 4px; font-weight: 500; color: #374151; font-size: 13px;">Project Name</label>
                                <input type="text" placeholder="My Project" value="${project.name || ''}"
                                       onchange="updateEditProject(${index}, 'name', this.value)"
                                       style="width: 100%; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;"
                                       id="edit-project-name-${index}">
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 12px; margin-bottom: 12px;">
                            <div>
                                <label style="display: block; margin-bottom: 4px; font-weight: 500; color: #374151; font-size: 13px;">Project Path *</label>
                                <div style="display: flex; gap: 6px;">
                                    <input type="text" value="${project.path || ''}" onchange="updateEditProject(${index}, 'path', this.value)"
                                           placeholder="/path/to/project" style="flex: 1; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;"
                                           id="edit-project-path-${index}">
                                    <button type="button" onclick="browseForEditFolder(${index})" class="btn btn-sm"
                                            style="white-space: nowrap; padding: 4px 8px; font-size: 11px;" title="Browse for folder">
                                        üìÅ Browse
                                    </button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 4px; font-weight: 500; color: #374151; font-size: 13px;">Access Level</label>
                                <select onchange="updateEditProject(${index}, 'access', this.value)" style="width: 100%; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;">
                                    <option value="write" ${project.access === 'write' ? 'selected' : ''}>Write</option>
                                    <option value="read" ${project.access === 'read' ? 'selected' : ''}>Read</option>
                                </select>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr 80px; gap: 12px; margin-bottom: 12px;">
                            <div>
                                <label style="display: block; margin-bottom: 4px; font-weight: 500; color: #374151; font-size: 13px;">Base Branch</label>
                                <select id="edit-project-base-branch-${index}" onchange="updateEditProject(${index}, 'base_branch', this.value)" style="width: 100%; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;">
                                    <option value="">Auto-detect current branch</option>
                                </select>
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 4px; font-weight: 500; color: #374151; font-size: 13px;">Task Branch</label>
                                <input type="text" value="${project.branch_name || ''}" onchange="updateEditProject(${index}, 'branch_name', this.value)"
                                       placeholder="Auto-generate" style="width: 100%; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 4px; font-weight: 500; color: #374151; font-size: 13px;">Load</label>
                                <button type="button" onclick="loadEditProjectBranches(${index})" style="width: 100%; padding: 6px 8px; background: #3b82f6; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">Load</button>
                            </div>
                        </div>

                        <div>
                            <label style="display: block; margin-bottom: 4px; font-weight: 500; color: #374151; font-size: 13px;">Project Context</label>
                            <textarea onchange="updateEditProject(${index}, 'context', this.value)"
                                      placeholder="Describe this project's role in the task..."
                                      style="width: 100%; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; min-height: 60px; resize: vertical;">${project.context || ''}</textarea>
                        </div>
                    </div>
                `;
            });

            html += `
                <div style="text-align: center; margin-top: 12px;">
                    <button type="button" onclick="addEditProject()" style="background: #10b981; color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 13px; cursor: pointer;">
                        + Add Another Project
                    </button>
                </div>
            `;

            container.innerHTML = html;

            // Pre-populate base branch dropdowns for existing projects
            editProjectsData.forEach((project, index) => {
                if (project.base_branch) {
                    const select = document.getElementById(`edit-project-base-branch-${index}`);
                    if (select) {
                        const option = document.createElement('option');
                        option.value = project.base_branch;
                        option.textContent = project.base_branch;
                        option.selected = true;
                        select.appendChild(option);
                    }
                }
            });
        }

        function updateEditProject(index, field, value) {
            if (editProjectsData[index]) {
                editProjectsData[index][field] = value;
            }
        }

        function addEditProject() {
            editProjectsData.push({
                path: '',
                access: 'write',
                context: '',
                base_branch: '',
                branch_name: ''
            });
            renderEditProjectsConfiguration();
        }

        function removeEditProject(index) {
            if (editProjectsData.length > 1) {
                editProjectsData.splice(index, 1);
                renderEditProjectsConfiguration();
            }
        }

        async function loadEditProjectBranches(projectIndex) {
            const project = editProjectsData[projectIndex];
            if (!project || !project.path || project.path.trim() === '') {
                alert('Please specify a project path first');
                return;
            }
            try {
                const response = await fetch(`${API_BASE}/git-branches?path=${encodeURIComponent(project.path)}&branch_type=local`);
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to load branches');
                }
                const data = await response.json();
                const select = document.getElementById(`edit-project-base-branch-${projectIndex}`);
                select.innerHTML = '<option value="">Auto-detect current branch</option>';
                data.branches.forEach(branch => {
                    const option = document.createElement('option');
                    option.value = branch;
                    option.textContent = branch;
                    if (branch === data.current_branch) {
                        option.textContent += ' (current)';
                        option.selected = true;
                        editProjectsData[projectIndex].base_branch = branch;
                    }
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading project branches:', error);
                alert(`Error loading branches for project: ${error.message}`);
            }
        }

        function renderEditProjectsList(projects) {
            const container = document.getElementById('editProjectsList');

            if (!projects || projects.length === 0) {
                container.innerHTML = '<div style="color: #9ca3af; font-style: italic; text-align: center; padding: 20px;">No projects configured for this task.</div>';
                return;
            }

            let html = '';
            projects.forEach((project, index) => {
                const accessColor = project.access === 'write' ? '#059669' : '#dc2626';
                const accessBadge = project.access === 'write' ? '‚úì Write' : 'üëÅ Read';

                html += `
                    <div style="background: white; border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px; margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div style="font-weight: 600; color: #374151; font-size: 14px;">${project.name || `Project ${index + 1}`}</div>
                            <div style="background: ${accessColor}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 500;">
                                ${accessBadge}
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 8px; font-size: 12px;">
                            <div>
                                <div style="color: #6b7280; margin-bottom: 2px;">Project Path:</div>
                                <div style="font-family: monospace; color: #374151; background: #f9fafb; padding: 4px 6px; border-radius: 3px;">
                                    ${project.path || 'Not specified'}
                                </div>
                            </div>
                            <div>
                                <div style="color: #6b7280; margin-bottom: 2px;">Base Branch:</div>
                                <div style="color: #374151;">${project.base_branch || 'Auto-detect'}</div>
                            </div>
                            <div>
                                <div style="color: #6b7280; margin-bottom: 2px;">Task Branch:</div>
                                <div style="color: #374151;">${project.branch_name || 'Auto-generate'}</div>
                            </div>
                        </div>
                        ${project.context ? `
                            <div style="margin-top: 8px;">
                                <div style="color: #6b7280; margin-bottom: 2px; font-size: 12px;">Context:</div>
                                <div style="color: #374151; font-size: 13px; line-height: 1.4;">${project.context}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Open directory browser
        async function selectDirectory() {
            document.getElementById('directoryModal').classList.add('show');
            await loadDirectories();
        }

        // Load directories from server
        async function loadDirectories(path = null) {
            const dirList = document.getElementById('dirList');
            const currentPathSpan = document.getElementById('currentPath');
            const parentBtn = document.getElementById('parentBtn');

            dirList.innerHTML = '<li class="loading" style="padding: 20px; text-align: center;">Loading...</li>';

            try {
                const url = path ?
                    `${API_BASE}/browse-directories?path=${encodeURIComponent(path)}` :
                    `${API_BASE}/browse-directories`;

                const response = await fetch(url);
                const data = await response.json();

                currentBrowsePath = data.current_path;
                currentPathSpan.textContent = data.current_path;

                // Enable/disable parent button
                parentBtn.disabled = !data.parent_path;

                // Render directories
                if (data.directories.length === 0) {
                    dirList.innerHTML = '<li style="padding: 20px; text-align: center; color: #6b7280;">No subdirectories</li>';
                } else {
                    dirList.innerHTML = data.directories.map(dir => `
                        <li class="dir-item ${dir.accessible ? '' : 'disabled'}"
                            onclick="${dir.accessible ? `navigateToDirectory('${dir.path.replace(/'/g, "\\'")}')` : ''}">
                            <span class="dir-icon">${dir.accessible ? 'üìÅ' : 'üîí'}</span>
                            <span>${dir.name}</span>
                        </li>
                    `).join('');
                }
            } catch (error) {
                dirList.innerHTML = `<li style="padding: 20px; color: #ef4444;">Error: ${error.message}</li>`;
            }
        }

        // Navigate to a directory
        async function navigateToDirectory(path) {
            await loadDirectories(path);
        }

        // Go to parent directory
        async function goToParent() {
            const currentPathSpan = document.getElementById('currentPath');
            const currentPath = currentPathSpan.textContent;

            // Get parent path
            const pathParts = currentPath.split('/');
            pathParts.pop();
            const parentPath = pathParts.join('/') || '/';

            await loadDirectories(parentPath);
        }

        // Select current directory
        function selectCurrentDirectory() {
            if (currentBrowsePath) {
                document.getElementById('rootFolder').value = currentBrowsePath;
                localStorage.setItem('lastRootFolder', currentBrowsePath);
                closeDirectoryModal();
            }
        }

        // Close directory modal
        function closeDirectoryModal() {
            document.getElementById('directoryModal').classList.remove('show');
            currentBrowsePath = null;
        }

        // Project folder browsing state
        let currentProjectIndex = null;
        let isEditMode = false;

        // Browse for folder (create task form)
        function browseForFolder(projectIndex) {
            currentProjectIndex = projectIndex;
            isEditMode = false;
            document.getElementById('directoryModal').classList.add('show');
            loadDirectories();
        }

        // Browse for folder (edit task form)
        function browseForEditFolder(projectIndex) {
            currentProjectIndex = projectIndex;
            isEditMode = true;
            document.getElementById('directoryModal').classList.add('show');
            loadDirectories();
        }

        // Override the existing selectCurrentDirectory function to handle project paths
        const originalSelectCurrentDirectory = selectCurrentDirectory;
        function selectCurrentDirectory() {
            if (currentProjectIndex !== null) {
                // Handle project path selection
                if (currentBrowsePath) {
                    if (isEditMode) {
                        // Update edit form project path
                        const input = document.getElementById(`edit-project-path-${currentProjectIndex}`);
                        if (input) {
                            input.value = currentBrowsePath;
                            updateEditProject(currentProjectIndex, 'path', currentBrowsePath);
                        }
                    } else {
                        // Update create form project path
                        const input = document.getElementById(`project-path-${currentProjectIndex}`);
                        if (input) {
                            input.value = currentBrowsePath;
                            updateProject(currentProjectIndex, 'path', currentBrowsePath);
                        }
                    }
                    closeDirectoryModal();
                    currentProjectIndex = null;
                    isEditMode = false;
                }
            } else {
                // Fall back to original behavior for root folder selection
                originalSelectCurrentDirectory();
            }
        }


        async function loadProjectBranches(projectIndex) {
            const project = projectsData[projectIndex];

            if (!project || !project.path || project.path.trim() === '') {
                alert('Please specify a project path first');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/git-branches?path=${encodeURIComponent(project.path)}&branch_type=local`);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to load branches');
                }

                const data = await response.json();

                const select = document.getElementById(`project-base-branch-${projectIndex}`);
                select.innerHTML = '<option value="">Auto-detect current branch</option>';

                data.branches.forEach(branch => {
                    const option = document.createElement('option');
                    option.value = branch;
                    option.textContent = branch;
                    if (branch === data.current_branch) {
                        option.textContent += ' (current)';
                        option.selected = true;
                        projectsData[projectIndex].base_branch = branch;
                    }
                    select.appendChild(option);
                });

                console.log(`Loaded ${data.branches.length} branches for project: ${project.path}`);
            } catch (error) {
                console.error('Error loading project branches:', error);
                alert(`Error loading branches for project: ${error.message}`);
            }
        }

        // Close modal when clicking outside
        document.getElementById('directoryModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeDirectoryModal();
            }
        });

        // Close project template modal when clicking outside
        document.getElementById('projectTemplateModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeProjectTemplateModal();
            }
        });

        // Create task
        document.getElementById('createTaskForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            // Validate projects configuration
            if (projectsData.length === 0) {
                showAlert('createAlert', 'Please add at least one project to the configuration.', 'error');
                return;
            }

            // Validate that all projects have paths
            const invalidProjects = projectsData.filter(p => !p.path || p.path.trim() === '');
            if (invalidProjects.length > 0) {
                showAlert('createAlert', 'All projects must have a valid path specified.', 'error');
                return;
            }

            const endCriteria = document.getElementById('endCriteria').value.trim();
            const maxIterations = document.getElementById('maxIterations').value;
            const maxTokens = document.getElementById('maxTokens').value;

            const taskData = {
                task_name: document.getElementById('taskName').value,
                description: document.getElementById('description').value,
                projects: projectsData,
                use_worktree: document.getElementById('useWorktree').checked,
                auto_start: document.getElementById('autoStart').checked,
                end_criteria: endCriteria || null,
                max_iterations: maxIterations ? parseInt(maxIterations) : null,
                max_tokens: maxTokens ? parseInt(maxTokens) : null
            };

            try {
                const response = await fetch(`${API_BASE}/tasks`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(taskData)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to create task');
                }

                const task = await response.json();
                showAlert('createAlert', `Task "${task.task_name}" created successfully!`, 'success');
                document.getElementById('createTaskForm').reset();
                document.getElementById('useWorktree').checked = true;

                // Reset projects data
                projectsData = [];
                renderProjectsList();

                // Hide the form and scroll to task list
                setTimeout(() => {
                    toggleCreateForm();
                }, 1500);

                refreshTasksKeepingTab();
            } catch (error) {
                showAlert('createAlert', error.message, 'error');
            }
        });

        // Global variable to track tab preservation
        let tabToPreserve = null;
        let tabPreservationInProgress = false;

        // Smart refresh that preserves current tab state
        async function refreshTasksKeepingTab(filter = null) {
            console.log('üîÑ refreshTasksKeepingTab: Starting tab preservation process');
            tabPreservationInProgress = true;

            // Remember current active tab in tab view
            const currentActiveTab = document.querySelector('.task-tab.active');
            const activeTaskName = currentActiveTab ? currentActiveTab.dataset.taskName : null;

            // Get current view mode to restore after refresh
            const viewModeElement = document.querySelector('input[name="viewMode"]:checked');
            const currentViewMode = viewModeElement ? viewModeElement.value : 'list';

            console.log('üîÑ refreshTasksKeepingTab: Current state before refresh:');
            console.log('  - Active task:', activeTaskName);
            console.log('  - View mode:', currentViewMode);
            console.log('  - Current active tab element:', currentActiveTab);
            console.log('  - Filter parameter:', filter);

            // DEBUGGING: Let's see ALL the current tabs
            const allTabs = document.querySelectorAll('.task-tab');
            console.log('üîç ALL CURRENT TABS:');
            allTabs.forEach((tab, index) => {
                console.log(`  ${index + 1}. Task: ${tab.dataset.taskName}, Active: ${tab.classList.contains('active')}`);
            });

            // Set global variable for tab preservation
            if (currentViewMode === 'tabs' && activeTaskName) {
                tabToPreserve = activeTaskName;
                console.log('üîÑ refreshTasksKeepingTab: Set tabToPreserve to:', tabToPreserve);
            } else {
                tabToPreserve = null;
                console.log('üîÑ refreshTasksKeepingTab: No tab to preserve (not in tab view or no active tab)');
                console.log('  - Reason: currentViewMode =', currentViewMode, ', activeTaskName =', activeTaskName);
            }

            // Do the full task reload
            console.log('üîÑ refreshTasksKeepingTab: Calling loadTasks() with filter:', filter);
            await loadTasks(filter);
            console.log('üîÑ refreshTasksKeepingTab: loadTasks() completed');

            // Tab preservation is now handled by the global variable and renderTabView()
            console.log('üîÑ refreshTasksKeepingTab: Tab preservation delegated to renderTabView via global variable');
            console.log('üîÑ refreshTasksKeepingTab: Current tabToPreserve value:', tabToPreserve);

            // Clear the flag after a delay to allow tab preservation to complete
            setTimeout(() => {
                tabPreservationInProgress = false;
                console.log('üîÑ refreshTasksKeepingTab: Tab preservation completed, flag cleared');
            }, 100);
        }

        // Load tasks
        async function loadTasks(status = null) {
            const tasksList = document.getElementById('tasksList');
            const viewModeElement = document.querySelector('input[name="viewMode"]:checked');
            const viewMode = viewModeElement ? viewModeElement.value : 'list';
            console.log('loadTasks: Current view mode:', viewMode, 'Element:', viewModeElement);

            // Show loading message in the appropriate view
            if (viewMode === 'list') {
                tasksList.innerHTML = '<div class="loading">Loading...</div>';
            } else {
                const taskTabs = document.getElementById('taskTabs');
                const taskContent = document.getElementById('taskContent');
                taskTabs.innerHTML = '<div style="padding: 12px 20px; color: #6b7280;">Loading...</div>';
                taskContent.innerHTML = '<div class="no-task-selected">Loading tasks...</div>';
            }

            try {
                let url = `${API_BASE}/tasks?limit=50`;
                if (status) url += `&status=${status}`;

                const response = await fetch(url);
                const tasks = await response.json();

                if (tasks.length === 0) {
                    if (viewMode === 'list') {
                        tasksList.innerHTML = '<div class="loading">No tasks found</div>';
                    } else {
                        const taskTabs = document.getElementById('taskTabs');
                        const taskContent = document.getElementById('taskContent');
                        taskTabs.innerHTML = '<div style="padding: 12px 20px; color: #6b7280;">No tasks found</div>';
                        taskContent.innerHTML = '<div class="no-task-selected">No tasks available</div>';
                    }
                    return;
                }

                // Fetch detailed status for each task
                const tasksWithStatus = await Promise.all(
                    tasks.map(async (task) => {
                        try {
                            const statusResponse = await fetch(`${API_BASE}/tasks/by-name/${task.task_name}/status`);
                            const status = await statusResponse.json();
                            return { ...task, statusDetails: status };
                        } catch {
                            return task;
                        }
                    })
                );

                // Store the tasks data globally for tab view
                window.currentTasks = tasksWithStatus;

                // Render based on view mode
                if (viewMode === 'list') {
                    console.log('Rendering List view with', tasksWithStatus.length, 'tasks');

                    // Generate batch controls HTML
                    const batchControlsHTML = `
                        <!-- Select All Controls -->
                        <div class="select-all-container">
                            <input type="checkbox" id="selectAllTasks" class="task-checkbox" onchange="toggleSelectAll()">
                            <label for="selectAllTasks">Select All Tasks</label>
                        </div>

                        <!-- Batch Action Toolbar -->
                        <div id="batchToolbar" class="batch-selection-toolbar">
                            <div class="batch-selection-info">
                                <span id="selectedCount">0</span> task(s) selected
                            </div>
                            <div class="batch-actions">
                                <button onclick="batchStartTasks()" class="btn btn-success btn-sm">üöÄ Start</button>
                                <button onclick="batchDeleteTasks()" class="btn btn-danger btn-sm">üóëÔ∏è Delete Task</button>
                                <button onclick="batchClearAndRestartTasks()" class="btn btn-warning btn-sm">üîÑ Clear & Restart</button>
                                <button onclick="batchRefreshTasks()" class="btn btn-sm">üîÑ Refresh</button>
                                <button onclick="clearSelection()" class="btn btn-sm">‚úñÔ∏è Clear Selection</button>
                            </div>
                        </div>
                    `;

                    // Render batch controls + tasks
                    const tasksHTML = tasksWithStatus.map(task => renderTask(task, true)).join('');
                    console.log('Generated batch controls HTML length:', batchControlsHTML.length);
                    console.log('Generated tasks HTML length:', tasksHTML.length);

                    tasksList.innerHTML = batchControlsHTML + tasksHTML;
                    console.log('Set tasksList innerHTML, total length:', (batchControlsHTML + tasksHTML).length);

                    // Debug: Check if checkboxes are actually in the DOM
                    setTimeout(() => {
                        const checkboxes = document.querySelectorAll('.task-checkbox');
                        console.log('Found', checkboxes.length, 'checkboxes in DOM');
                        checkboxes.forEach((cb, index) => {
                            console.log(`Checkbox ${index}:`, cb, 'visible:', cb.offsetWidth > 0 && cb.offsetHeight > 0);
                        });
                    }, 100);

                    // Update selection state after rendering tasks
                    updateSelection();
                } else {
                    console.log('Rendering Tab view');
                    renderTabView(tasksWithStatus);
                }
            } catch (error) {
                const tasksContainer = document.getElementById('tasksContainer') || tasksList;
                tasksContainer.innerHTML = `<div class="error-message">Error loading tasks: ${error.message}</div>`;
            }
        }

        // Render task
        function renderTask(task, showCheckbox = false) {
            console.log('renderTask called for', task.task_name, 'showCheckbox:', showCheckbox);
            const status = task.statusDetails || task;
            const statusClass = `status-${status.status.toLowerCase()}`;

            let actions = '';
            const statusLower = status.status.toLowerCase();
            if (statusLower === 'pending') {
                actions = `<button onclick="startTask('${task.task_name}')" class="btn btn-success btn-sm">Start</button>`;
            } else if (['running', 'paused', 'testing'].includes(statusLower) || status.process_running) {
                actions = `<button onclick="stopTask('${task.task_name}')" class="btn btn-danger btn-sm">Stop</button>`;
            } else if (statusLower === 'stopped') {
                actions = `<button onclick="resumeTask('${task.task_name}')" class="btn btn-success btn-sm">Resume</button>`;
            }
            actions += `<button onclick="refreshTask('${task.task_name}')" class="btn btn-sm">üîÑ Refresh</button>`;
            actions += `<button onclick="viewConversation('${task.task_name}')" class="btn btn-sm">üí¨ View Conversation</button>`;
            actions += `<button onclick="editTask('${task.task_name}')" class="btn btn-sm">‚úèÔ∏è Edit</button>`;
            actions += `<button onclick="cloneTask('${task.task_name}')" class="btn btn-sm">üìã Clone</button>`;
            actions += `<button onclick="clearAndRestartTaskByName(event, '${task.task_name}')" class="btn btn-warning btn-sm" title="Clear conversation and restart task">üîÑ Clear & Restart</button>`;

            // Show "Delete Worktrees" button if task has project worktrees or legacy worktree
            const hasWorktrees = (status.projects && status.projects.some(p => p.access === 'write')) || status.worktree_path;
            if (hasWorktrees) {
                const buttonText = (status.projects && status.projects.length > 1) ? 'Delete Worktrees' : 'Delete Worktree';
                actions += `<button onclick="deleteWorktree('${task.task_name}', event)" class="btn btn-warning btn-sm" title="Remove project worktrees only, keep task & conversation">üóÇÔ∏è ${buttonText}</button>`;
            }

            actions += `<button onclick="deleteTask('${task.task_name}', event)" class="btn btn-danger btn-sm">üóëÔ∏è Delete Task</button>`;

            let claudeResponse = '';
            if (status.latest_claude_response) {
                const truncated = status.latest_claude_response.substring(0, 200);
                claudeResponse = `<div class="task-claude">üí¨ Claude: ${truncated}${status.latest_claude_response.length > 200 ? '...' : ''}</div>`;
            }

            let testSummary = '';
            if (status.test_summary && status.test_summary.total > 0) {
                const ts = status.test_summary;
                testSummary = `
                    <div class="test-summary">
                        <div class="test-stat">‚úÖ Passed: ${ts.passed}</div>
                        <div class="test-stat">‚ùå Failed: ${ts.failed}</div>
                        <div class="test-stat">‚è≥ Pending: ${ts.pending}</div>
                        <div class="test-stat">üìä Total: ${ts.total}</div>
                    </div>
                `;
            }

            // Build task details
            let taskDetails = '';
            const details = [];

            if (task.root_folder) {
                details.push(`<div class="task-detail-item"><span class="task-detail-label">üìÅ Project:</span><span class="task-detail-value">${task.root_folder}</span></div>`);
            }

            if (task.branch_name) {
                details.push(`<div class="task-detail-item"><span class="task-detail-label">üåø Branch:</span><span class="task-detail-value">${task.branch_name}</span></div>`);
            }

            if (task.base_branch) {
                details.push(`<div class="task-detail-item"><span class="task-detail-label">‚ö° Base Branch:</span><span class="task-detail-value">${task.base_branch}</span></div>`);
            }

            // Display per-project worktrees instead of single task worktree
            if (task.projects && task.projects.length > 0) {
                const writeProjects = task.projects.filter(p => p.access === 'write');
                if (writeProjects.length > 0) {
                    const worktreeDisplay = writeProjects.map(project => {
                        // Generate worktree path based on project and task
                        const projectWorktreePath = project.worktree_path ||
                            `${project.path}/.claude_worktrees/${task.task_name.replace(/[/\s]/g, '_')}`;
                        return `<div style="margin-left: 16px; margin-bottom: 4px;">
                            <strong>${project.name || 'Unnamed Project'}:</strong><br>
                            <code style="font-size: 11px; color: #666;">${projectWorktreePath}</code>
                        </div>`;
                    }).join('');

                    details.push(`<div class="task-detail-item">
                        <span class="task-detail-label">üîß Project Worktrees:</span>
                        <div class="task-detail-value">${worktreeDisplay}</div>
                    </div>`);
                }
            } else if (task.worktree_path) {
                // Fallback to single worktree display for legacy tasks
                details.push(`<div class="task-detail-item"><span class="task-detail-label">üîß Worktree:</span><span class="task-detail-value">${task.worktree_path}</span></div>`);
            }

            if (task.created_at) {
                const created = new Date(task.created_at).toLocaleString();
                details.push(`<div class="task-detail-item"><span class="task-detail-label">‚è∞ Created:</span><span class="task-detail-value">${created}</span></div>`);
            }

            if (details.length > 0) {
                taskDetails = `<div class="task-details"><div class="task-detail-row">${details.join('')}</div></div>`;
            }

            // Projects info
            let projectsInfo = '';
            if (task.projects && task.projects.length > 0) {
                const projectItems = task.projects.map((project, index) => {
                    const projectName = project.name || `Project ${index + 1}`;
                    const accessIcon = project.access === 'write' ? '‚úèÔ∏è' : 'üëÅÔ∏è';
                    const contextText = project.context ? ` - ${project.context}` : '';
                    return `<div class="task-detail-item">
                        <span class="task-detail-label">${accessIcon} ${projectName}:</span>
                        <span class="task-detail-value">${project.path}${contextText}</span>
                    </div>`;
                }).join('');
                projectsInfo = `<div class="task-details"><div class="task-detail-row">${projectItems}</div></div>`;
            }

            // Ending criteria and limits info
            let criteriaInfo = '';
            if (task.end_criteria_config) {
                const config = typeof task.end_criteria_config === 'string' ? JSON.parse(task.end_criteria_config) : task.end_criteria_config;
                const criteriaItems = [];

                if (config.criteria) {
                    criteriaItems.push(`<div class="task-detail-item"><span class="task-detail-label">üéØ Success Criteria:</span><span class="task-detail-value">${config.criteria}</span></div>`);
                }
                if (config.max_iterations) {
                    const currentIterations = task.interaction_count || 0;
                    const maxIterations = config.max_iterations;
                    const iterationPercent = Math.min((currentIterations / maxIterations) * 100, 100);
                    const iterationColor = iterationPercent > 90 ? '#ef4444' : iterationPercent > 70 ? '#f59e0b' : '#10b981';

                    criteriaItems.push(`
                        <div class="task-detail-item" style="flex-direction: column; gap: 4px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="task-detail-label">üîÑ Iterations:</span>
                                <span class="task-detail-value"><strong>${currentIterations} / ${maxIterations}</strong></span>
                            </div>
                            <div style="width: 100%; height: 6px; background: #e5e7eb; border-radius: 3px; overflow: hidden;">
                                <div style="width: ${iterationPercent}%; height: 100%; background: ${iterationColor}; transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                    `);
                }
                // Always show token usage (whether there's a limit or not)
                const currentTokens = task.total_tokens_used || 0;
                if (config.max_tokens) {
                    // Show tokens with progress bar when there's a limit
                    const maxTokens = config.max_tokens;
                    const tokenPercent = Math.min((currentTokens / maxTokens) * 100, 100);
                    const tokenColor = tokenPercent > 90 ? '#ef4444' : tokenPercent > 70 ? '#f59e0b' : '#10b981';

                    criteriaItems.push(`
                        <div class="task-detail-item" style="flex-direction: column; gap: 4px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="task-detail-label">üé´ Tokens:</span>
                                <span class="task-detail-value"><strong>${currentTokens.toLocaleString()} / ${maxTokens.toLocaleString()}</strong></span>
                            </div>
                            <div style="width: 100%; height: 6px; background: #e5e7eb; border-radius: 3px; overflow: hidden;">
                                <div style="width: ${tokenPercent}%; height: 100%; background: ${tokenColor}; transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                    `);
                } else if (currentTokens > 0) {
                    // Show token count without progress bar when no limit is set
                    criteriaItems.push(`
                        <div class="task-detail-item">
                            <span class="task-detail-label">üé´ Tokens Used:</span>
                            <span class="task-detail-value"><strong>${currentTokens.toLocaleString()}</strong></span>
                        </div>
                    `);
                }
                if (config.warning) {
                    criteriaItems.push(`<div class="task-detail-item" style="color: #f59e0b;"><span class="task-detail-label">‚ö†Ô∏è Warning:</span><span class="task-detail-value">${config.warning}</span></div>`);
                }

                if (criteriaItems.length > 0) {
                    criteriaInfo = `<div class="task-details"><div class="task-detail-row">${criteriaItems.join('')}</div></div>`;
                }
            }

            // Task description
            let taskDesc = '';
            if (task.description && task.description.length > 0) {
                const descPreview = task.description.length > 150 ?
                    task.description.substring(0, 150) + '...' :
                    task.description;
                taskDesc = `<div class="task-description">üìù ${descPreview}</div>`;
            }

            // Note: Input functionality is now only available in the conversation modal (opened via "View Conversation" button)

            // Build compact metrics for list view
            let compactMetrics = '';

            // Extract key dynamic information
            const currentTokens = task.total_tokens_used || 0;
            const currentIterations = task.interaction_count || 0;

            // Add token usage
            if (currentTokens > 0) {
                compactMetrics += `<span class="metric">üé´ ${currentTokens.toLocaleString()} tokens</span>`;
            }

            // Add iterations
            if (currentIterations > 0) {
                compactMetrics += `<span class="metric">üîÑ ${currentIterations} iterations</span>`;
            }

            // Add special statuses
            if (status.waiting_for_input) {
                compactMetrics += `<span class="metric">‚è∏Ô∏è Waiting for input</span>`;
            }

            const checkboxHTML = showCheckbox ? `<input type="checkbox" class="task-checkbox task-selector" data-task-name="${task.task_name}" onchange="updateSelection()">` : '';
            console.log('Task', task.task_name, 'checkbox HTML:', checkboxHTML);

            return `
                <div class="task-item" data-task-name="${task.task_name}">
                    ${checkboxHTML}
                    <div class="task-item-content">
                        <div class="task-header">
                            <div class="task-name">${task.task_name}</div>
                            <span class="task-status ${statusClass}">${status.status}</span>
                        </div>
                        <div class="task-progress">üìç ${status.progress || 'No progress info'}</div>
                        ${compactMetrics ? `<div class="task-metrics">${compactMetrics}</div>` : ''}
                        ${status.error_message ? `<div class="error-message">${status.error_message}</div>` : ''}
                        <div class="task-actions">${actions}</div>
                        ${status.status.toLowerCase() === 'running' || status.waiting_for_input ? `
                            <div class="task-message-box" style="margin-top: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: #f9f9f9;">
                                <div style="display: flex; gap: 6px; align-items: center;">
                                    <input type="text"
                                           id="taskMessage_${task.task_name}"
                                           placeholder="Send message to ${task.task_name}..."
                                           style="flex: 1; padding: 4px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 12px;"
                                           onkeydown="if(event.key==='Enter') sendTaskMessage('${task.task_name}')">
                                    <button onclick="sendTaskMessage('${task.task_name}')"
                                            class="btn btn-primary btn-sm"
                                            style="padding: 4px 8px; font-size: 11px;">
                                        üì§ Send
                                    </button>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        // Send message to individual task
        async function sendTaskMessage(taskName) {
            const inputElement = document.getElementById(`taskMessage_${taskName}`);
            if (!inputElement) {
                console.error('Input element not found for task:', taskName);
                return;
            }

            const message = inputElement.value.trim();
            if (!message) {
                console.log('No message to send');
                return;
            }

            try {
                console.log('Sending message to task:', taskName, 'Message:', message);

                const response = await fetch(`${API_BASE}/tasks/by-name/${taskName}/message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to send message');
                }

                // Clear the input field after successful send
                inputElement.value = '';
                console.log('Message sent successfully');

                // Optionally refresh the task to show updated status
                setTimeout(() => refreshTasksKeepingTab(), 500);

            } catch (error) {
                console.error('Error sending message:', error);
                alert(`Error sending message: ${error.message}`);
            }
        }

        // Task actions
        async function startTask(taskName) {
            try {
                await fetch(`${API_BASE}/tasks/by-name/${taskName}/start`, { method: 'POST' });
                await refreshTasksKeepingTab();
            } catch (error) {
                alert(`Error starting task: ${error.message}`);
            }
        }

        async function stopTask(taskName) {
            // Add confirmation dialog
            if (!confirm(`Are you sure you want to stop the task "${taskName}"?\n\nThis will terminate the current task execution.`)) {
                return;
            }

            try {
                await fetch(`${API_BASE}/tasks/by-name/${taskName}/stop`, { method: 'POST' });
                await refreshTasksKeepingTab();
            } catch (error) {
                alert(`Error stopping task: ${error.message}`);
            }
        }

        async function resumeTask(taskName) {
            try {
                await fetch(`${API_BASE}/tasks/by-name/${taskName}/resume`, { method: 'POST' });
                await refreshTasksKeepingTab();
            } catch (error) {
                alert(`Error resuming task: ${error.message}`);
            }
        }

        async function refreshSingleTask(taskName) {
            try {
                // Fetch the updated task data for just this specific task
                const response = await fetch(`${API_BASE}/tasks/by-name/${taskName}`);
                const updatedTask = await response.json();

                // Find the existing task element in the DOM
                const tasksList = document.getElementById('tasksList');
                const taskItems = tasksList.querySelectorAll('.task-item');

                // Find the specific task element to update
                for (let taskItem of taskItems) {
                    const taskNameElement = taskItem.querySelector('.task-name');
                    if (taskNameElement && taskNameElement.textContent === taskName) {
                        // Check if we're in List view to determine if checkboxes should be shown
                        const isListView = document.getElementById('tasksList').style.display !== 'none';
                        console.log(`Refreshing task ${taskName}, isListView: ${isListView}, showCheckbox: ${isListView}`);
                        // Replace this task element with the updated version
                        taskItem.outerHTML = renderTask(updatedTask, isListView);
                        break;
                    }
                }
            } catch (error) {
                console.error(`Error refreshing single task ${taskName}:`, error);
                // Fall back to full refresh if single task refresh fails
                refreshTasksKeepingTab();
            }
        }

        async function refreshTask(taskName) {
            try {
                // Refresh only the specific task without affecting page scroll
                await refreshSingleTask(taskName);

                // If the conversation view is open for this task, refresh it too
                const conversationSection = document.getElementById('conversationSection');
                if (currentTaskName === taskName && conversationSection && conversationSection.style.display === 'block') {
                    await loadConversation(taskName, true); // true flag for auto-scroll
                }
            } catch (error) {
                alert(`Error refreshing task: ${error.message}`);
            }
        }

        async function clearAndRestartTask() {
            if (!currentTaskName) {
                alert('No task selected');
                return;
            }

            if (!confirm(`Are you sure you want to clear all conversation history and restart task "${currentTaskName}"? This cannot be undone.`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/tasks/by-name/${currentTaskName}/clear-and-restart`, { method: 'POST' });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to clear and restart task');
                }

                const result = await response.json();
                showToast(result.message || 'Task conversation cleared and restarted successfully');

                // Refresh the conversation view
                await loadConversation(currentTaskName);

                // Refresh the task list
                await refreshTasksKeepingTab();
            } catch (error) {
                alert(`Error clearing and restarting task: ${error.message}`);
            }
        }

        // Clear and restart task by name (for use in task list)
        async function clearAndRestartTaskByName(event, taskName) {
            console.log('üîÑ clearAndRestartTaskByName: Starting clear and restart for task:', taskName);

            // DEBUGGING: Let's see the current state before we do anything
            const viewModeElement = document.querySelector('input[name="viewMode"]:checked');
            const currentViewMode = viewModeElement ? viewModeElement.value : 'unknown';
            const currentActiveTab = document.querySelector('.task-tab.active');
            const activeTaskName = currentActiveTab ? currentActiveTab.dataset.taskName : null;

            console.log('üîç BEFORE clearAndRestartTaskByName:');
            console.log('  - Button clicked for task:', taskName);
            console.log('  - Current view mode:', currentViewMode);
            console.log('  - Current active tab element:', currentActiveTab);
            console.log('  - Current active task name:', activeTaskName);
            console.log('  - Are we in tabs view?', currentViewMode === 'tabs');
            console.log('  - Is there an active tab?', !!activeTaskName);
            console.log('  - Should preserve tab?', currentViewMode === 'tabs' && activeTaskName);

            // CRITICAL: Explicitly set the tab to preserve RIGHT NOW, before any async operations
            if (currentViewMode === 'tabs' && activeTaskName) {
                tabToPreserve = activeTaskName;
                console.log('üîÑ clearAndRestartTaskByName: EARLY SET tabToPreserve to:', tabToPreserve);
            } else {
                tabToPreserve = null;
                console.log('üîÑ clearAndRestartTaskByName: EARLY SET tabToPreserve to null');
            }

            const result = await showCustomConfirm(
                `Are you sure you want to clear all conversation history and restart task "${taskName}"? This cannot be undone.`,
                event.target
            );
            if (!result) {
                console.log('üîÑ clearAndRestartTaskByName: User cancelled operation');
                return;
            }

            try {
                console.log('üîÑ clearAndRestartTaskByName: Making API call to clear and restart task');
                const response = await fetch(`${API_BASE}/tasks/by-name/${taskName}/clear-and-restart`, { method: 'POST' });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to clear and restart task');
                }

                const result = await response.json();
                console.log('üîÑ clearAndRestartTaskByName: API call successful, showing toast');
                showToast(result.message || 'Task conversation cleared and restarted successfully');

                // Refresh the task list
                console.log('üîÑ clearAndRestartTaskByName: Calling refreshTasksKeepingTab()');
                await refreshTasksKeepingTab();

                // If this task is currently open in the conversation modal, refresh it too
                if (currentTaskName === taskName) {
                    console.log('üîÑ clearAndRestartTaskByName: Task is currently open in conversation, refreshing modal');
                    await loadConversation(currentTaskName);
                }

                console.log('üîÑ clearAndRestartTaskByName: Clear and restart operation completed');
            } catch (error) {
                console.log('‚ùå clearAndRestartTaskByName: Error occurred:', error.message);
                alert(`Error clearing and restarting task: ${error.message}`);
            }
        }



        async function deleteTask(taskName, event) {
            const confirmed = await showCustomConfirm(`Delete task "${taskName}"?\n\nThis will permanently delete the task, conversation history, and worktree.`, event.target);
            if (!confirmed) return;

            try {
                await fetch(`${API_BASE}/tasks/by-name/${taskName}`, { method: 'DELETE' });
                refreshTasksKeepingTab();
            } catch (error) {
                alert(`Error deleting task: ${error.message}`);
            }
        }

        // Delete only the worktree(s) (keep task and conversation)
        async function deleteWorktree(taskName, event) {
            // First get task details to understand if it has multiple projects
            try {
                const taskResponse = await fetch(`${API_BASE}/tasks/by-name/${taskName}/status`);
                if (!taskResponse.ok) {
                    throw new Error('Failed to fetch task details');
                }

                const taskData = await taskResponse.json();
                const hasMultipleProjects = taskData.projects && taskData.projects.length > 1;
                const writeProjects = taskData.projects ? taskData.projects.filter(p => p.access === 'write') : [];

                // Prepare confirmation message based on whether we have multiple projects
                let confirmMessage;
                if (hasMultipleProjects && writeProjects.length > 1) {
                    const projectList = writeProjects.map(p => `‚Ä¢ ${p.name || 'Unnamed Project'}`).join('\n');
                    confirmMessage = `Remove worktrees for task "${taskName}"?\n\nThis will delete isolated workspaces for:\n${projectList}\n\nIf the task is running, it will be automatically stopped first.\nThe task and conversation history will be preserved.\n\nYou can then checkout the branches in your IDE.`;
                } else if (writeProjects.length === 1) {
                    confirmMessage = `Remove worktree for task "${taskName}"?\n\nThis will ONLY delete the isolated workspace for:\n‚Ä¢ ${writeProjects[0].name || 'Main Project'}\n\nIf the task is running, it will be automatically stopped first.\nThe task and conversation history will be preserved.\n\nYou can then checkout the branch in your IDE.`;
                } else {
                    confirmMessage = `Remove worktree for task "${taskName}"?\n\nThis will ONLY delete the isolated workspace.\n\nIf the task is running, it will be automatically stopped first.\nThe task and conversation history will be preserved.\n\nYou can then checkout the branch in your IDE.`;
                }

                const confirmed = await showCustomConfirm(confirmMessage, event.target);
                if (!confirmed) return;

                const response = await fetch(`${API_BASE}/tasks/by-name/${taskName}/worktree?auto_stop=true`, { method: 'DELETE' });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to delete worktree');
                }

                const result = await response.json();
                const successMessage = hasMultipleProjects && writeProjects.length > 1
                    ? result.message + '\n\nYou can now checkout the branches in your IDE.'
                    : result.message + '\n\nYou can now checkout the branch in your IDE.';
                showToast(successMessage);
                refreshTasksKeepingTab();
            } catch (error) {
                alert(`Error deleting worktree: ${error.message}`);
            }
        }

        // Clone task
        async function cloneTask(taskName) {
            // Add confirmation dialog
            if (!confirm(`Are you sure you want to clone the task "${taskName}"?\n\nThis will create a duplicate task with the same configuration and conversation history.`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/tasks/by-name/${taskName}/clone`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to clone task');
                }

                const result = await response.json();
                alert(`Task cloned successfully!\nNew task: ${result.new_task}`);
                refreshTasksKeepingTab();
            } catch (error) {
                alert(`Error cloning task: ${error.message}`);
            }
        }

        // Edit task - open modal and load task data
        async function editTask(taskName) {
            try {
                // Fetch task details
                const response = await fetch(`${API_BASE}/tasks/by-name/${taskName}`);
                if (!response.ok) {
                    throw new Error('Failed to load task details');
                }

                const task = await response.json();

                // Populate form
                document.getElementById('editTaskName').value = task.task_name;
                document.getElementById('editDescription').value = task.description || '';
                // Handle backward compatibility for legacy single-project tasks
                let projectsForEditing = task.projects;
                if (!projectsForEditing && task.root_folder) {
                    // Convert legacy single-project format to multi-project format for editing
                    projectsForEditing = [{
                        path: task.root_folder,
                        access: "write",
                        context: task.project_context || "Legacy single-project task",
                        base_branch: task.base_branch || "",
                        branch_name: task.branch_name || ""
                    }];
                }

                // Populate projects configuration (now editable)
                setupEditProjectsConfiguration(projectsForEditing || []);

                // Handle end criteria config
                const endCriteriaConfig = task.end_criteria_config || {};
                document.getElementById('editEndCriteria').value = endCriteriaConfig.criteria || '';
                document.getElementById('editMaxIterations').value = endCriteriaConfig.max_iterations || '';
                document.getElementById('editMaxTokens').value = endCriteriaConfig.max_tokens || '';

                // Show modal
                document.getElementById('editTaskModal').classList.add('show');
            } catch (error) {
                alert(`Error loading task: ${error.message}`);
            }
        }

        // Close edit modal
        function closeEditModal() {
            document.getElementById('editTaskModal').classList.remove('show');
            document.getElementById('editAlert').innerHTML = '';
        }

        // Save task edits
        async function saveTaskEdit() {
            const taskName = document.getElementById('editTaskName').value;

            // Build end criteria config
            const endCriteriaConfig = {};
            const criteria = document.getElementById('editEndCriteria').value;
            const maxIterations = document.getElementById('editMaxIterations').value;
            const maxTokens = document.getElementById('editMaxTokens').value;

            if (criteria) endCriteriaConfig.criteria = criteria;
            if (maxIterations) endCriteriaConfig.max_iterations = parseInt(maxIterations);
            if (maxTokens) endCriteriaConfig.max_tokens = parseInt(maxTokens);

            // Process projects data - filter out empty projects and ensure at least one project path is provided
            const validProjects = editProjectsData.filter(project => project.path && project.path.trim() !== '');

            const updateData = {
                description: document.getElementById('editDescription').value,
                end_criteria_config: Object.keys(endCriteriaConfig).length > 0 ? endCriteriaConfig : null,
                projects: validProjects.length > 0 ? validProjects : null
            };

            try {
                const response = await fetch(`${API_BASE}/tasks/by-name/${taskName}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updateData)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to update task');
                }

                showAlert('editAlert', 'Task updated successfully!', 'success');
                setTimeout(() => {
                    closeEditModal();
                    refreshTasksKeepingTab();
                }, 1500);
            } catch (error) {
                showAlert('editAlert', error.message, 'error');
            }
        }

        // Show alert
        function showAlert(elementId, message, type) {
            const alert = document.getElementById(elementId);
            alert.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
            setTimeout(() => alert.innerHTML = '', 5000);
        }

        // Conversation Modal Functions
        let eventSource = null;

        async function viewConversation(taskName) {
            currentTaskName = taskName;
            document.getElementById('conversationModal').classList.add('show');

            // Check if task is running, then use streaming
            try {
                const statusResponse = await fetch(`${API_BASE}/tasks/by-name/${taskName}/status`);
                const statusData = await statusResponse.json();

                if (statusData.status === 'running' || statusData.status === 'paused') {
                    await loadConversationStreaming(taskName);
                } else {
                    await loadConversation(taskName, true);
                }
            } catch (error) {
                // Fallback to static loading
                await loadConversation(taskName, true);
            }
        }

        async function loadConversation(taskName, autoScroll = true) {
            const content = document.getElementById('conversationContent');
            content.innerHTML = '<div class="loading">Loading conversation...</div>';

            // Close any existing event source
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }

            try {
                // Check if task is running and use streaming instead
                const statusResponse = await fetch(`${API_BASE}/tasks/by-name/${taskName}/status`);
                const statusData = await statusResponse.json();

                if (['running', 'paused', 'testing'].includes(statusData.status.toLowerCase()) || statusData.process_running) {
                    // Use streaming for active tasks
                    loadConversationStreaming(taskName);
                    return;
                }

                const response = await fetch(`${API_BASE}/tasks/by-name/${taskName}/conversation`);
                const data = await response.json();

                if (data.conversation.length === 0) {
                    content.innerHTML = '<p style="text-align: center; color: #6b7280;">No conversation yet</p>';
                    return;
                }

                // Use the renderMessages function for consistent rendering
                renderMessages(content, data.conversation);

                // Always auto-scroll to bottom by default for better UX
                // Force immediate scroll to bottom - no optional parameter needed
                scrollToBottom(content, false); // Immediate, non-smooth scroll

                // Additional scrolls for reliability
                setTimeout(() => scrollToBottom(content, false), 50);
                setTimeout(() => scrollToBottom(content, true), 150);

                // Use requestAnimationFrame for maximum reliability
                requestAnimationFrame(() => {
                    content.scrollTop = content.scrollHeight;
                    requestAnimationFrame(() => {
                        content.scrollTop = content.scrollHeight;
                    });
                });
            } catch (error) {
                content.innerHTML = `<div class="error-message">Error loading conversation: ${error.message}</div>`;
            }
        }

        async function loadConversationStreaming(taskName) {
            const content = document.getElementById('conversationContent');
            content.innerHTML = '<div class="loading" style="text-align: center; padding: 20px; font-size: 16px; color: #667eea;"><div style="display: inline-block; animation: pulse 2s infinite;">üî¥ Live streaming conversation...</div><br><small style="color: #6b7280; margin-top: 10px; display: block;">New messages will appear automatically</small></div>';

            // Close any existing event source using centralized management
            closeStreamingConnection('modal');

            // Start streaming using centralized management
            streamingConnections.modal = new EventSource(`${API_BASE}/tasks/by-name/${encodeURIComponent(taskName)}/stream`);

            const messages = [];

            streamingConnections.modal.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);

                    // Handle status updates
                    if (data.type === 'status') {
                        // Update header to show status
                        document.querySelector('#conversationModal .modal-header h2').textContent =
                            `üî¥ Live Stream - ${data.status.toUpperCase()} (${data.total_interactions} messages)`;

                        // If task completed, close stream and reload
                        if (data.status === 'completed' || data.status === 'failed' || data.status === 'stopped') {
                            closeStreamingConnection('modal');
                            document.querySelector('#conversationModal .modal-header h2').textContent = 'üó®Ô∏è Task Conversation';
                            setTimeout(() => loadConversation(taskName), 500);
                        }
                    } else {
                        // Handle new interaction message
                        messages.push(data);
                        renderMessages(content, messages);

                        // Setup minimap after streaming message updates (modal view)
                        setTimeout(() => {
                            setupConversationMinimap(messages, 'conversationMinimapModal', 'conversationContent');
                        }, 50);

                        // Auto-scroll to bottom for streaming updates
                        setTimeout(() => {
                            scrollToBottom(content, true);
                        }, 50);
                    }
                } catch (error) {
                    console.error('Error parsing SSE data:', error);
                }
            };

            streamingConnections.modal.onerror = function(error) {
                console.error('Modal streaming error:', error);
                closeStreamingConnection('modal');
                content.innerHTML += '<div class="error-message">Stream connection lost. Reloading...</div>';
                setTimeout(() => loadConversation(taskName), 2000);
            };
        }

        function renderMessages(container, messages) {
            console.log('üéØ RENDER MESSAGES: Called with', messages.length, 'messages, container:', container);
            // Clear container
            container.innerHTML = '';

            messages.forEach((msg, index) => {
                // Skip messages with empty or whitespace-only content
                if (!msg.content || (typeof msg.content === 'string' && msg.content.trim() === '')) {
                    return;
                }

                // Additional check for null, undefined, or non-string content that might appear empty
                if (msg.content === null || msg.content === undefined || msg.content === 'null' || msg.content === 'undefined') {
                    return;
                }

                const messageClass = msg.type === 'claude_response' ? 'message-claude' :
                                   msg.type === 'simulated_human' ? 'message-simulated' :
                                   msg.type === 'tool_result' ? 'message-tool' :
                                   msg.type === 'tool_group' ? 'message-tool' :
                                   'message-user';
                const messageLabel = msg.type === 'claude_response' ? 'ü§ñ Claude' :
                                   msg.type === 'simulated_human' ? 'üé≠ Simulated Human' :
                                   msg.type === 'tool_result' ? 'üîß Tool Result' :
                                   msg.type === 'tool_group' ? 'üîß Tool Results' :
                                   'üë§ Human';

                // Check if this is the last USER_REQUEST message
                const isLastUserRequest = msg.type === 'user_request' &&
                    (index === messages.length - 1 ||
                    messages.slice(index + 1).every(m => m.type !== 'user_request'));

                // Create message div
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${messageClass}`;
                messageDiv.id = `conversation-item-${index}`;  // Add ID for minimap navigation
                messageDiv.setAttribute('data-msg-id', msg.id);
                messageDiv.setAttribute('data-msg-index', index);


                // Create header
                const header = document.createElement('div');
                header.className = 'message-header';

                const typeSpan = document.createElement('span');
                typeSpan.className = 'message-type';
                typeSpan.textContent = messageLabel;

                const timeSpan = document.createElement('span');
                timeSpan.textContent = new Date(msg.timestamp).toLocaleString();

                header.appendChild(typeSpan);
                header.appendChild(timeSpan);

                // Add edit button if needed
                if (msg.type === 'user_request' && isLastUserRequest) {
                    const editBtn = document.createElement('button');
                    editBtn.className = 'btn btn-sm';
                    editBtn.textContent = '‚úèÔ∏è Edit';
                    editBtn.title = 'Edit this message';
                    editBtn.onclick = () => editInteraction(msg.id, index);
                    header.appendChild(editBtn);
                }

                // Create content - special handling for tool results and tool groups
                if (msg.type === 'tool_result' || msg.type === 'tool_group') {
                    // Create collapsible tool result
                    const collapsedDiv = document.createElement('div');
                    collapsedDiv.className = 'tool-result-collapsed';

                    let content, summaryText;
                    const expandIcon = document.createElement('span');
                    expandIcon.className = 'expand-icon';
                    expandIcon.textContent = '‚ñ∂';

                    if (msg.type === 'tool_group') {
                        // Handle tool group - show summary and individual tools
                        summaryText = msg.summary || `Tool execution results (${msg.tool_count} tools)`;

                        const summarySpan = document.createElement('span');
                        summarySpan.textContent = summaryText;

                        collapsedDiv.appendChild(summarySpan);
                        collapsedDiv.appendChild(expandIcon);

                        // Create expanded content div with all individual tools
                        const contentDiv = document.createElement('div');
                        contentDiv.className = 'message-content tool-result-hidden';
                        contentDiv.id = `msg-content-${msg.id}`;

                        // Render each tool in the group
                        msg.tools.forEach((tool, toolIndex) => {
                            const toolDiv = document.createElement('div');
                            toolDiv.className = 'tool-item';
                            toolDiv.style.marginBottom = '10px';
                            toolDiv.style.padding = '8px';
                            toolDiv.style.backgroundColor = '#f8f9fa';
                            toolDiv.style.borderLeft = '3px solid #6c757d';

                            const toolHeader = document.createElement('div');
                            toolHeader.style.fontWeight = 'bold';
                            toolHeader.style.marginBottom = '5px';
                            toolHeader.style.fontSize = '12px';
                            toolHeader.style.color = '#495057';
                            toolHeader.textContent = `Tool ${toolIndex + 1} (${new Date(tool.timestamp).toLocaleTimeString()})`;

                            const toolContent = document.createElement('pre');
                            toolContent.style.margin = '0';
                            toolContent.style.fontSize = '12px';
                            toolContent.style.whiteSpace = 'pre-wrap';
                            toolContent.style.wordBreak = 'break-word';
                            toolContent.textContent = tool.content || '';

                            toolDiv.appendChild(toolHeader);
                            toolDiv.appendChild(toolContent);
                            contentDiv.appendChild(toolDiv);
                        });

                        content = contentDiv; // Store reference to contentDiv
                    } else {
                        // Handle individual tool result
                        const toolContent = msg.content || '';
                        const lines = toolContent.split('\n');
                        const firstLine = lines[0] || 'Tool result';
                        const totalLines = lines.length;
                        const summary = firstLine.length > 80 ? firstLine.substring(0, 80) + '...' : firstLine;

                        const summarySpan = document.createElement('span');
                        summarySpan.textContent = `${summary} (${totalLines} lines)`;

                        collapsedDiv.appendChild(summarySpan);
                        collapsedDiv.appendChild(expandIcon);

                        // Create full content div (initially hidden)
                        const contentDiv = document.createElement('div');
                        contentDiv.className = 'message-content tool-result-hidden';
                        contentDiv.id = `msg-content-${msg.id}`;
                        contentDiv.textContent = toolContent;

                        content = contentDiv; // Store reference to contentDiv
                    }

                    // Add click handler to toggle
                    collapsedDiv.onclick = () => {
                        const isHidden = content.classList.contains('tool-result-hidden');
                        if (isHidden) {
                            content.classList.remove('tool-result-hidden');
                            content.classList.add('tool-result-expanded');
                            expandIcon.textContent = '‚ñº';
                            collapsedDiv.style.display = 'none';
                        }
                    };

                    // Add click handler to collapse back
                    content.onclick = () => {
                        content.classList.remove('tool-result-expanded');
                        content.classList.add('tool-result-hidden');
                        expandIcon.textContent = '‚ñ∂';
                        collapsedDiv.style.display = 'flex';
                    };

                    messageDiv.appendChild(header);
                    messageDiv.appendChild(collapsedDiv);
                    messageDiv.appendChild(content);
                } else {
                    // Regular content for non-tool messages
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'message-content';
                    contentDiv.id = `msg-content-${msg.id}`;
                    contentDiv.textContent = msg.content;  // Use textContent to avoid escaping issues

                    messageDiv.appendChild(header);
                    messageDiv.appendChild(contentDiv);
                }

                container.appendChild(messageDiv);
            });

            // Auto-scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function refreshConversation() {
            if (currentTaskName) {
                await loadConversation(currentTaskName, true); // Auto-scroll to bottom after refresh
            }
        }

        function closeConversationModal() {
            document.getElementById('conversationModal').classList.remove('show');
            // Clear the message input
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.value = '';
            }

            // Close modal streaming connection
            closeStreamingConnection('modal');

            // Reset header
            document.querySelector('#conversationModal .modal-header h2').textContent = 'üó®Ô∏è Task Conversation';

            currentTaskName = null;
        }

        function toggleInputEditor() {
            // Legacy function - UI simplified, no longer needed
            // Focus on the new persistent message input instead
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.focus();
            }
        }

        async function sendCustomInput() {
            // Legacy function - redirect to new sendMessage function
            // This function is kept for backward compatibility with any old button references
            await sendMessage();
        }

        let currentMessages = [];

        async function editInteraction(interactionId, msgIndex) {
            if (!currentTaskName) {
                alert('No task selected');
                return;
            }

            // Check if task is stopped or paused
            const statusResponse = await fetch(`${API_BASE}/tasks/by-name/${currentTaskName}/status`);
            const statusData = await statusResponse.json();

            if (statusData.status === 'running') {
                if (!confirm('Task is currently running. It will be stopped to edit this message. Do you want to continue?')) {
                    return;
                }
                // Stop the task first
                await stopTask(currentTaskName);
            }

            // Get the current message content
            const msgContent = document.getElementById(`msg-content-${interactionId}`);
            const currentContent = msgContent.textContent;

            // Create inline editor
            const newContent = prompt('Edit the message content:', currentContent);

            if (newContent === null || newContent === currentContent) {
                return; // User cancelled or no changes
            }

            if (!newContent.trim()) {
                alert('Message content cannot be empty');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/interactions/${interactionId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: newContent })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to update interaction');
                }

                alert('Message updated! You can now resume the task.');

                // Reload the conversation
                await loadConversation(currentTaskName);
                refreshTasksKeepingTab(); // Refresh task list
            } catch (error) {
                alert(`Error updating message: ${error.message}`);
            }
        }

        // Close modal when clicking outside
        document.getElementById('conversationModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeConversationModal();
            }
        });

        // View switching functionality
        function toggleViewMode() {
            const viewMode = document.querySelector('input[name="viewMode"]:checked').value;
            const tasksList = document.getElementById('tasksList');
            const tasksTabView = document.getElementById('tasksTabView');

            // Clean up all streaming connections when switching views
            closeAllStreamingConnections();

            // Note: Keep fixed input box in tabs view - it's now part of the permanent HTML structure

            if (viewMode === 'list') {
                tasksList.style.display = 'block';
                tasksTabView.style.display = 'none';
                document.body.classList.remove('tabs-view'); // Enable scrolling for list view

                // Completely disable the tab input box and its events in List view
                const tabInput = document.getElementById('tabMessageInput');
                const tabInputButton = document.querySelector('.fixed-tab-input button');
                if (tabInput) {
                    tabInput.disabled = true;
                    tabInput.style.display = 'none';
                    // Remove event handlers
                    tabInput.onkeydown = null;
                }
                if (tabInputButton) {
                    tabInputButton.disabled = true;
                    tabInputButton.style.display = 'none';
                    // Remove event handlers
                    tabInputButton.onclick = null;
                }
            } else {
                tasksList.style.display = 'none';
                tasksTabView.style.display = 'block';
                document.body.classList.add('tabs-view'); // Disable scrolling for tabs view

                // Re-enable the tab input box in Tab view
                const tabInput = document.getElementById('tabMessageInput');
                const tabInputButton = document.querySelector('.fixed-tab-input button');
                if (tabInput) {
                    tabInput.disabled = false;
                    tabInput.style.display = 'block';
                    // Restore the Enter key handler that was removed
                    tabInput.onkeydown = function(event) {
                        if(event.key === 'Enter') sendTabMessageFromInput();
                    };
                }
                if (tabInputButton) {
                    tabInputButton.disabled = false;
                    tabInputButton.style.display = 'block';
                    // Restore the click handler that was removed
                    tabInputButton.onclick = sendTabMessageFromInput;
                }
            }

            // Reload tasks for the new view mode
            refreshTasksKeepingTab();
        }

        // Render tab view
        function renderTabView(tasks) {
            const taskTabs = document.getElementById('taskTabs');
            const taskContent = document.getElementById('taskContent');

            // Generate tabs
            const tabsHtml = tasks.map(task => {
                return `
                    <button class="task-tab" data-task-name="${task.task_name}" onclick="selectTab('${task.task_name}')">
                        ${task.task_name}
                    </button>
                `;
            }).join('');

            taskTabs.innerHTML = tabsHtml;

            // Handle tab selection based on preservation logic
            if (tasks.length > 0) {
                setTimeout(() => {
                    console.log('üîÑ renderTabView: Starting tab selection logic');
                    console.log('üîç renderTabView: tabToPreserve =', tabToPreserve);
                    console.log('üîç renderTabView: typeof tabToPreserve =', typeof tabToPreserve);
                    console.log('üîç renderTabView: tabToPreserve is truthy?', !!tabToPreserve);

                    if (tabToPreserve) {
                        // Check if the tab to preserve exists
                        console.log('üîç renderTabView: Looking for tab with selector:', `.task-tab[data-task-name="${tabToPreserve}"]`);
                        const preserveTab = document.querySelector(`.task-tab[data-task-name="${tabToPreserve}"]`);
                        console.log('üîç renderTabView: Found preserve tab element:', preserveTab);

                        if (preserveTab) {
                            console.log('üîÑ renderTabView: Preserving tab:', tabToPreserve);
                            selectTab(tabToPreserve);
                            tabToPreserve = null; // Clear after use
                            console.log('üîÑ renderTabView: Cleared tabToPreserve, now =', tabToPreserve);
                        } else {
                            console.log('üîÑ renderTabView: Tab to preserve not found, selecting first tab:', tasks[0].task_name);
                            selectTab(tasks[0].task_name);
                            tabToPreserve = null; // Clear after use
                            console.log('üîÑ renderTabView: Cleared tabToPreserve, now =', tabToPreserve);
                        }
                    } else {
                        console.log('üîÑ renderTabView: No tab to preserve (tabToPreserve is falsy)');
                        // No tab to preserve, check if any tab is already active
                        const currentActiveTab = document.querySelector('.task-tab.active');
                        console.log('üîç renderTabView: Current active tab:', currentActiveTab);

                        if (!currentActiveTab) {
                            console.log('üîÑ renderTabView: No active tab found, selecting first tab:', tasks[0].task_name);
                            selectTab(tasks[0].task_name);
                        } else {
                            console.log('üîÑ renderTabView: Active tab already exists, keeping:', currentActiveTab.dataset.taskName);
                        }
                    }
                }, 50);
            } else {
                taskContent.innerHTML = '<div class="no-task-selected">No tasks available</div>';
            }
        }

        // Select a tab and show its content
        async function selectTab(taskName) {

            console.log('selectTab called with taskName:', taskName);
            // Close any existing tab streaming connection
            closeStreamingConnection('tab');

            // Update tab appearance
            const allTabs = document.querySelectorAll('.task-tab');
            allTabs.forEach(tab => tab.classList.remove('active'));

            const selectedTab = document.querySelector(`.task-tab[data-task-name="${taskName}"]`);
            console.log('Found selectedTab:', selectedTab?.getAttribute('data-task-name') || 'not found');
            if (selectedTab) {
                selectedTab.classList.add('active');
                console.log('Set tab as active:', taskName);
            }

            // Load task conversation
            const taskContent = document.getElementById('taskContent');
            taskContent.innerHTML = '<div class="loading">Loading conversation...</div>';

            try {
                // Check if task is running and use streaming
                const statusResponse = await fetch(`${API_BASE}/tasks/by-name/${taskName}/status`);
                const statusData = await statusResponse.json();

                if (['running', 'paused', 'testing'].includes(statusData.status.toLowerCase()) || statusData.process_running) {
                    // Use streaming for active tasks
                    loadTabStreaming(taskName);
                    return;
                }

                const response = await fetch(`${API_BASE}/tasks/by-name/${taskName}/conversation`);
                const conversationData = await response.json();

                // Extract the conversation array from the response
                const conversation = conversationData.conversation || [];

                // Find the task data
                const task = window.currentTasks.find(t => t.task_name === taskName);
                const status = task?.statusDetails || task;

                // Minimal task header for tab view
                const taskHeaderHtml = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 2px 0; border-bottom: 1px solid #e5e7eb;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <h3 style="margin: 0; color: #1f2937; font-size: 16px;">üìã ${taskName}</h3>
                            <span class="status-badge status-${status?.status?.toLowerCase() || 'unknown'}" style="font-size: 11px; padding: 2px 6px;">${status?.status || 'Unknown'}</span>
                        </div>
                        <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                            ${renderTabViewTaskActions(task)}
                        </div>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <p style="margin: 0; color: #6b7280; font-size: 14px;"><strong>Description:</strong> ${task?.description || 'No description'}</p>
                    </div>
                `;

                const conversationContainerHtml = `
                    <div class="conversation-nav-container">
                        <div class="conversation-content">
                            <div id="tabConversationContainer" style="overflow-y: auto; padding: 6px; margin: 0; border: none; height: 100%; max-height: calc(100vh - 200px);">
                                ${conversation.length > 0
                                    ? conversation.map((interaction, index) => `
                                        <div class="conversation-item ${interaction.type.toLowerCase()}" id="conversation-item-${index}">
                                            <div class="interaction-header">
                                                <strong>${formatInteractionType(interaction.type)}</strong>
                                                <span class="timestamp">${formatDate(interaction.timestamp)}</span>
                                            </div>
                                            <div class="interaction-content">${formatContent(interaction.content)}</div>
                                        </div>
                                    `).join('')
                                    : '<div class="no-conversation">No conversation yet</div>'
                                }
                            </div>
                        </div>
                        <div id="conversationNavSidebar" class="conversation-nav-sidebar">
                            <div class="conversation-minimap" id="conversationMinimap">
                                <div class="conversation-viewport-indicator" id="viewportIndicator"></div>
                            </div>
                        </div>
                    </div>
                `;

                // Use the original approach but add navigation indicators
                taskContent.innerHTML = `
                    ${taskHeaderHtml}
                    ${conversationContainerHtml}
                `;

                // Setup conversation minimap after DOM is updated
                setTimeout(() => {
                    setupConversationMinimap(conversation);
                }, 100);

                // Auto-scroll to bottom immediately and repeatedly for reliability
                const conversationContainer = document.getElementById('tabConversationContainer');
                if (conversationContainer && conversation.length > 0) {
                    // Immediate scroll
                    scrollToBottom(conversationContainer, false);

                    // Additional scrolls to ensure it works
                    setTimeout(() => scrollToBottom(conversationContainer, false), 50);
                    setTimeout(() => scrollToBottom(conversationContainer, false), 150);
                    setTimeout(() => scrollToBottom(conversationContainer, true), 300);

                    // Use requestAnimationFrame for even more reliability
                    requestAnimationFrame(() => {
                        const timeSinceLastClick = Date.now() - lastMiniMapClickTime;
                        if (timeSinceLastClick >= 200) {
                            conversationContainer.scrollTop = conversationContainer.scrollHeight;
                            requestAnimationFrame(() => {
                                const timeSinceLastClick2 = Date.now() - lastMiniMapClickTime;
                                if (timeSinceLastClick2 >= 200) {
                                    conversationContainer.scrollTop = conversationContainer.scrollHeight;
                                }
                            });
                        }
                    });
                }
            } catch (error) {
                taskContent.innerHTML = `<div class="error-message">Error loading conversation: ${error.message}</div>`;
            }
        }

        // Tab streaming function
        async function loadTabStreaming(taskName) {
            const taskContent = document.getElementById('taskContent');
            const task = window.currentTasks.find(t => t.task_name === taskName);
            const status = task?.statusDetails || task;

            // Minimal task header for streaming tab view
            const taskHeaderHtml = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 2px 0; border-bottom: 1px solid #e5e7eb;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <h3 style="margin: 0; color: #1f2937; font-size: 16px;">üìã ${taskName}</h3>
                        <span class="status-badge status-${status?.status?.toLowerCase() || 'unknown'}" style="font-size: 11px; padding: 2px 6px;">${status?.status || 'Unknown'}</span>
                        <span style="color: #dc2626; font-size: 12px; font-weight: 500;">üî¥ Live</span>
                    </div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        ${renderTabViewTaskActions(task)}
                    </div>
                </div>
                <div style="margin-bottom: 8px;">
                    <p style="margin: 0; color: #6b7280; font-size: 14px;"><strong>Description:</strong> ${task?.description || 'No description'}</p>
                </div>
            `;

            const conversationContainerHtml = `
                <div class="conversation-nav-container">
                    <div class="conversation-content">
                        <div id="tabConversationContainer" style="overflow-y: auto; padding: 6px; margin: 0; border: none; height: 100%; max-height: calc(100vh - 200px);">
                            <div class="loading" style="text-align: center; padding: 20px; font-size: 16px; color: #667eea;">
                                <div style="display: inline-block; animation: pulse 2s infinite;">üî¥ Live streaming conversation...</div>
                                <br><small style="color: #6b7280; margin-top: 10px; display: block;">New messages will appear automatically</small>
                            </div>
                        </div>
                    </div>
                    <div id="conversationNavSidebar" class="conversation-nav-sidebar">
                        <div class="conversation-minimap" id="conversationMinimap">
                            <div class="conversation-viewport-indicator" id="viewportIndicator"></div>
                        </div>
                    </div>
                </div>
            `;

            // Use original approach for streaming
            taskContent.innerHTML = `
                ${taskHeaderHtml}
                ${conversationContainerHtml}
            `;

            // Navigation sidebar now contains minimap structure for streaming

            // Start streaming
            const conversationContainer = document.getElementById('tabConversationContainer');

            // Load existing conversation first, then setup minimap correctly
            let messages = [];
            console.log('üîß TAB DEBUG: Starting conversation loading for task:', taskName);
            console.log('üîß TAB DEBUG: Conversation container element:', conversationContainer);

            try {
                const url = `${API_BASE}/tasks/by-name/${taskName}/conversation`;
                console.log('üîß TAB DEBUG: Fetching conversation from:', url);

                const response = await fetch(url);
                console.log('üîß TAB DEBUG: Fetch response status:', response.status, response.ok);

                if (response.ok) {
                    const conversationData = await response.json();
                    console.log('üîß TAB DEBUG: Raw conversation data:', conversationData);

                    messages = conversationData.conversation || [];
                    console.log('üîß TAB DEBUG: Extracted messages array:', messages.length, 'messages');

                    // Render existing messages first
                    if (messages.length > 0) {
                        console.log('üîß TAB DEBUG: Calling renderMessages with', messages.length, 'messages');
                        renderMessages(conversationContainer, messages);
                        console.log('üîß TAB DEBUG: renderMessages completed');
                    } else {
                        console.log('üîß TAB DEBUG: No messages to render');
                    }
                } else {
                    console.error('üîß TAB DEBUG: Response not OK:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('üîß TAB DEBUG: Error loading existing conversation:', error);
            }

            // Setup minimap with existing messages (or empty if none)
            setTimeout(() => {
                setupConversationMinimap(messages, 'conversationMinimap', 'tabConversationContainer');
            }, 100);

            // Immediately scroll to bottom for streaming view
            setTimeout(() => {
                if (conversationContainer) {
                    const timeSinceLastClick = Date.now() - lastMiniMapClickTime;
                    if (timeSinceLastClick >= 200) {
                        conversationContainer.scrollTop = conversationContainer.scrollHeight;
                    }
                }
            }, 100);
            streamingConnections.tab = new EventSource(`${API_BASE}/tasks/by-name/${encodeURIComponent(taskName)}/stream`);

            // messages array already initialized above with existing conversation

            streamingConnections.tab.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('üéØ TAB STREAMING: Received message:', data);

                    // Handle status updates
                    if (data.type === 'status') {
                        // Update task meta
                        const taskMeta = taskContent.querySelector('.task-meta');
                        if (taskMeta) {
                            const statusBadge = taskMeta.querySelector('.status-badge');
                            const metaItem = taskMeta.querySelector('.task-meta-item');
                            if (statusBadge) {
                                statusBadge.textContent = data.status.toUpperCase();
                                statusBadge.className = `status-badge status-${data.status.toLowerCase()}`;
                            }
                            if (metaItem) {
                                metaItem.textContent = `üî¥ Live: ${data.total_interactions} messages`;
                            }
                        }

                        // If task completed, close stream and reload only if current tab
                        if (data.status === 'completed' || data.status === 'failed' || data.status === 'stopped') {
                            streamingConnections.tab.close();
                            streamingConnections.tab = null;
                            // Only refresh if this is the currently active tab
                            const activeTab = document.querySelector('.task-tab.active');
                            if (activeTab && activeTab.dataset.taskName === taskName) {
                                setTimeout(() => {
                                    if (!tabPreservationInProgress) {
                                        console.log('üîÑ Delayed selectTab: Calling selectTab for', taskName);
                                        selectTab(taskName);
                                    } else {
                                        console.log('üîÑ Delayed selectTab: Skipping selectTab due to tab preservation in progress');
                                    }
                                }, 500);
                            }
                        }
                    } else {
                        // Handle individual streaming message - backend now sends complete formatted messages
                        console.log('üéØ TAB STREAMING: Received streaming message (individual), current message count:', messages.length);
                        console.log('üéØ TAB STREAMING: Received interaction message:', data);
                        console.log('üéØ TAB STREAMING: Conversation container element:', conversationContainer);
                        console.log('üéØ TAB STREAMING: Container element exists?', !!conversationContainer);

                        // Check if this message already exists in our array (by ID)
                        const existingIndex = messages.findIndex(msg => msg.id === data.id);
                        if (existingIndex !== -1) {
                            // Update existing message
                            messages[existingIndex] = data;
                            console.log('üéØ TAB STREAMING: Updated existing message at index', existingIndex);
                        } else {
                            // Add new message
                            messages.push(data);
                            console.log('üéØ TAB STREAMING: Added new message, total count:', messages.length);
                        }

                        console.log('üéØ TAB STREAMING: About to call renderMessages with container:', conversationContainer?.id);
                        renderMessages(conversationContainer, messages);
                        console.log('üéØ TAB STREAMING: renderMessages call completed');

                        // Setup minimap after streaming message updates (tab view)
                        setTimeout(() => {
                            setupConversationMinimap(messages, 'conversationMinimap', 'tabConversationContainer');
                        }, 50);

                        // Auto-scroll to bottom for streaming updates
                        setTimeout(() => {
                            scrollToBottom(conversationContainer, true);
                        }, 50);
                    }
                } catch (error) {
                    console.error('Error parsing SSE data:', error);
                }
            };

            streamingConnections.tab.onerror = function(error) {
                console.error('Tab streaming error:', error);
                streamingConnections.tab.close();
                streamingConnections.tab = null;
                conversationContainer.innerHTML += '<div class="error-message">Stream connection lost. Reloading...</div>';
                // Only reload if this is the currently active tab
                const activeTab = document.querySelector('.task-tab.active');
                if (activeTab && activeTab.dataset.taskName === taskName) {
                    setTimeout(() => {
                        if (!tabPreservationInProgress) {
                            console.log('üîÑ Delayed selectTab (2s): Calling selectTab for', taskName);
                            selectTab(taskName);
                        } else {
                            console.log('üîÑ Delayed selectTab (2s): Skipping selectTab due to tab preservation in progress');
                        }
                    }, 2000);
                }
            };
        }

        // Helper functions for tab view
        function getStatusColor(status) {
            const colors = {
                'PENDING': '#6b7280',
                'RUNNING': '#3b82f6',
                'COMPLETED': '#10b981',
                'FAILED': '#ef4444',
                'STOPPED': '#f59e0b',
                'TESTING': '#8b5cf6'
            };
            return colors[status?.toUpperCase()] || '#6b7280';
        }

        function renderTaskActions(task) {
            const status = task?.statusDetails || task;
            const statusLower = status?.status?.toLowerCase() || '';

            let actions = '';
            if (statusLower === 'pending') {
                actions = `<button onclick="startTask('${task.task_name}')" class="btn btn-success btn-sm">Start</button>`;
            } else if (['running', 'paused', 'testing'].includes(statusLower) || status?.process_running) {
                actions = `<button onclick="stopTask('${task.task_name}')" class="btn btn-danger btn-sm">Stop</button>`;
            } else if (statusLower === 'stopped') {
                actions = `<button onclick="resumeTask('${task.task_name}')" class="btn btn-success btn-sm">Resume</button>`;
            }
            actions += `<button onclick="refreshTask('${task.task_name}')" class="btn btn-sm">üîÑ Refresh</button>`;
            actions += `<button onclick="clearAndRestartTaskByName(event, '${task.task_name}')" class="btn btn-secondary btn-sm">üîÑ Clear & Restart</button>`;
            actions += `<button onclick="viewConversation('${task.task_name}')" class="btn btn-sm">üí¨ Conversation</button>`;

            return actions;
        }

        // Enhanced task actions for tab view (includes all necessary management buttons)
        function renderTabViewTaskActions(task) {
            const status = task?.statusDetails || task;
            const statusLower = status?.status?.toLowerCase() || '';
            let actions = '';
            if (statusLower === 'pending') {
                actions = `<button onclick="startTask('${task.task_name}')" class="btn btn-success btn-sm">Start</button>`;
            } else if (['running', 'paused', 'testing'].includes(statusLower) || status?.process_running) {
                actions = `<button onclick="stopTask('${task.task_name}')" class="btn btn-danger btn-sm">Stop</button>`;
            } else if (statusLower === 'stopped') {
                actions = `<button onclick="resumeTask('${task.task_name}')" class="btn btn-success btn-sm">Resume</button>`;
            }
            // Tab view includes essential management buttons but excludes refresh and conversation (since we're already in conversation view)
            actions += `<button onclick="editTask('${task.task_name}')" class="btn btn-sm">‚úèÔ∏è Edit</button>`;
            actions += `<button onclick="cloneTask('${task.task_name}')" class="btn btn-sm">üìã Clone</button>`;
            actions += `<button onclick="clearAndRestartTaskByName(event, '${task.task_name}')" class="btn btn-warning btn-sm" title="Clear conversation and restart task">üîÑ Clear & Restart</button>`;

            // Show "Delete Worktrees" button if task has project worktrees or legacy worktree
            const hasWorktrees = (status.projects && status.projects.some(p => p.access === 'write')) || status.worktree_path;
            if (hasWorktrees) {
                const buttonText = (status.projects && status.projects.length > 1) ? 'Delete Worktrees' : 'Delete Worktree';
                actions += `<button onclick="deleteWorktree('${task.task_name}', event)" class="btn btn-warning btn-sm" title="Remove project worktrees only, keep task & conversation">üóÇÔ∏è ${buttonText}</button>`;
            }
            actions += `<button onclick="deleteTask('${task.task_name}', event)" class="btn btn-danger btn-sm">üóëÔ∏è Delete Task</button>`;

            return actions;
        }

        // Helper functions for conversation display
        function formatInteractionType(type) {
            const typeMap = {
                'user_request': 'üë§ User',
                'claude_response': 'ü§ñ Claude',
                'tool_result': 'üîß Tool',
                'user_input': 'üë§ User Input',
                'system': '‚öôÔ∏è System'
            };
            return typeMap[type] || type;
        }

        function formatDate(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                return date.toLocaleString();
            } catch (e) {
                return timestamp;
            }
        }

        function formatContent(content) {
            if (!content) return '';

            // Escape HTML to prevent XSS
            const escapeHtml = (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };

            // Handle content as string - escape and preserve line breaks
            const escapedContent = escapeHtml(content);
            return escapedContent.replace(/\n/g, '<br>');
        }

        // Auto-scroll helper function
        function scrollToBottom(element, smooth = true) {
            if (!element) return;

            // Don't auto-scroll-to-bottom for 200ms after mini-map click
            // This only prevents AUTO-scrolling to bottom, not manual user scrolling
            const timeSinceLastClick = Date.now() - lastMiniMapClickTime;
            if (timeSinceLastClick < 200) {
                console.log('Skipping auto-scroll-to-bottom - mini-map click was recent');
                return;
            }

            if (smooth) {
                element.scrollTo({
                    top: element.scrollHeight,
                    behavior: 'smooth'
                });
            } else {
                element.scrollTop = element.scrollHeight;
            }
        }


        // Streaming management for different views
        const streamingConnections = {
            modal: null,
            tab: null,
            list: new Map() // taskName -> eventSource
        };

        function closeStreamingConnection(viewType, taskName = null) {
            if (viewType === 'list' && taskName) {
                const eventSource = streamingConnections.list.get(taskName);
                if (eventSource) {
                    eventSource.close();
                    streamingConnections.list.delete(taskName);
                }
            } else if (streamingConnections[viewType]) {
                streamingConnections[viewType].close();
                streamingConnections[viewType] = null;
            }
        }

        function closeAllStreamingConnections() {
            // Close modal and tab connections
            if (streamingConnections.modal) {
                streamingConnections.modal.close();
                streamingConnections.modal = null;
            }
            if (streamingConnections.tab) {
                streamingConnections.tab.close();
                streamingConnections.tab = null;
            }
            // Close all list connections
            streamingConnections.list.forEach((eventSource, taskName) => {
                eventSource.close();
            });
            streamingConnections.list.clear();
        }

        // Auto-refresh management
        let autoRefreshInterval = null;

        function toggleAutoRefresh() {
            const checkbox = document.getElementById('autoRefresh');

            // Safety check: if checkbox doesn't exist, don't start auto-refresh
            if (!checkbox) {
                console.log('Auto-refresh checkbox not found, auto-refresh disabled');
                return;
            }

            if (checkbox.checked) {
                // Start auto-refresh
                autoRefreshInterval = setInterval(loadTasks, 5000);
                console.log('Auto-refresh enabled: polling every 5 seconds');
            } else {
                // Stop auto-refresh
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                    console.log('Auto-refresh disabled');
                }
            }
        }

        // Initial load
        loadTasks();

        // ============================================================================
        // Prompt Management Functions
        // ============================================================================

        let currentTargetField = null;  // Track which field prompts will be loaded into
        let allPrompts = [];  // Cache all prompts for filtering

        // Open prompt library modal
        async function openPromptLibrary(targetField) {
            currentTargetField = targetField;
            document.getElementById('promptLibraryModal').classList.add('show');
            await loadPrompts();
        }

        // Close prompt library
        function closePromptLibrary() {
            document.getElementById('promptLibraryModal').classList.remove('show');
            currentTargetField = null;
        }

        // Load prompts from API
        async function loadPrompts() {
            const promptList = document.getElementById('promptList');
            promptList.innerHTML = '<div class="loading">Loading prompts...</div>';

            try {
                const response = await fetch(`${API_BASE}/prompts?limit=100`);
                if (!response.ok) {
                    throw new Error('Failed to load prompts');
                }

                allPrompts = await response.json();
                renderPrompts(allPrompts);
            } catch (error) {
                promptList.innerHTML = `<div style="padding: 20px; color: #ef4444;">Error: ${error.message}</div>`;
            }
        }

        // Render prompts to the list
        function renderPrompts(prompts) {
            const promptList = document.getElementById('promptList');

            if (prompts.length === 0) {
                promptList.innerHTML = '<div style="padding: 20px; text-align: center; color: #6b7280;">No prompts found. Save your first prompt!</div>';
                return;
            }

            promptList.innerHTML = prompts.map(prompt => {
                const contentPreview = prompt.content.length > 150 ?
                    prompt.content.substring(0, 150) + '...' :
                    prompt.content;

                const categoryBadge = prompt.category ?
                    `<span class="prompt-category">${prompt.category}</span>` : '';

                const usageInfo = prompt.usage_count > 0 ?
                    `<span class="prompt-usage">Used ${prompt.usage_count} times</span>` : '';

                return `
                    <div class="prompt-item">
                        <div class="prompt-item-header">
                            <div class="prompt-title">${prompt.title}</div>
                            <div class="prompt-meta">
                                ${categoryBadge}
                                ${usageInfo}
                            </div>
                        </div>
                        <div class="prompt-content-preview">${contentPreview}</div>
                        <div class="prompt-actions">
                            <button onclick="usePrompt('${prompt.id}')" class="btn btn-sm btn-success">‚úì Use This</button>
                            <button onclick="editPromptDialog('${prompt.id}')" class="btn btn-sm">‚úèÔ∏è Edit</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Search prompts
        function searchPrompts() {
            const searchTerm = document.getElementById('promptSearch').value.toLowerCase();
            const category = document.getElementById('promptCategoryFilter').value;

            let filtered = allPrompts;

            if (searchTerm) {
                filtered = filtered.filter(p =>
                    p.title.toLowerCase().includes(searchTerm) ||
                    p.content.toLowerCase().includes(searchTerm) ||
                    (p.tags && p.tags.toLowerCase().includes(searchTerm))
                );
            }

            if (category) {
                filtered = filtered.filter(p => p.category === category);
            }

            renderPrompts(filtered);
        }

        // Filter prompts by category
        function filterPrompts() {
            searchPrompts();
        }

        // Use a prompt (load into target field)
        async function usePrompt(promptId) {
            try {
                // Mark as used
                await fetch(`${API_BASE}/prompts/${promptId}/use`, { method: 'POST' });

                // Get prompt content
                const prompt = allPrompts.find(p => p.id === promptId);
                if (!prompt) return;

                // Load content into target field
                if (currentTargetField) {
                    const field = document.getElementById(currentTargetField);

                    // For endCriteria fields, also load criteria_config if available
                    if ((currentTargetField === 'endCriteria' || currentTargetField === 'editEndCriteria') && prompt.criteria_config) {
                        field.value = prompt.criteria_config.criteria || prompt.content;

                        // Also populate max_iterations and max_tokens
                        if (prompt.criteria_config.max_iterations) {
                            const maxIterField = currentTargetField === 'editEndCriteria' ? 'editMaxIterations' : 'maxIterations';
                            const maxIterElement = document.getElementById(maxIterField);
                            if (maxIterElement) {
                                maxIterElement.value = prompt.criteria_config.max_iterations;
                            }
                        }
                        if (prompt.criteria_config.max_tokens) {
                            const maxTokensField = currentTargetField === 'editEndCriteria' ? 'editMaxTokens' : 'maxTokens';
                            const maxTokensElement = document.getElementById(maxTokensField);
                            if (maxTokensElement) {
                                maxTokensElement.value = prompt.criteria_config.max_tokens;
                            }
                        }
                    } else {
                        // For other fields, append content
                        const currentContent = field.value.trim();
                        if (currentContent) {
                            field.value = currentContent + '\n\n' + prompt.content;
                        } else {
                            field.value = prompt.content;
                        }
                    }
                }

                closePromptLibrary();
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        // Save current prompt
        function saveCurrentPrompt(sourceField) {
            const content = document.getElementById(sourceField).value.trim();

            if (!content) {
                alert('No content to save');
                return;
            }

            // Store source field for later use
            currentTargetField = sourceField;

            // Pre-fill content in save modal
            document.getElementById('promptContent').value = content;
            document.getElementById('promptTitle').value = '';
            document.getElementById('promptTags').value = '';

            // Pre-select category based on source field
            if (sourceField === 'endCriteria' || sourceField === 'editEndCriteria') {
                document.getElementById('promptCategory').value = 'criteria';
            } else {
                document.getElementById('promptCategory').value = '';
            }

            // Open save modal
            document.getElementById('savePromptModal').classList.add('show');
        }

        // Close save prompt modal
        function closeSavePrompt() {
            document.getElementById('savePromptModal').classList.remove('show');
        }

        // Alias function for saving prompts from edit task modal
        function saveToPromptLibrary(sourceField) {
            saveCurrentPrompt(sourceField);
        }

        // Save prompt to library
        async function savePromptToLibrary() {
            const title = document.getElementById('promptTitle').value.trim();
            const category = document.getElementById('promptCategory').value;
            const tags = document.getElementById('promptTags').value.trim();
            const content = document.getElementById('promptContent').value.trim();

            if (!title || !content) {
                alert('Title and content are required');
                return;
            }

            // Build prompt data
            const promptData = {
                title,
                content,
                category: category || null,
                tags: tags || null
            };

            // If saving criteria template, include max_iterations and max_tokens
            if (category === 'criteria') {
                const maxIterations = document.getElementById('maxIterations').value;
                const maxTokens = document.getElementById('maxTokens').value;

                promptData.criteria_config = {
                    criteria: content,
                    max_iterations: maxIterations ? parseInt(maxIterations) : 20,
                    max_tokens: maxTokens ? parseInt(maxTokens) : null
                };
            }

            try {
                const response = await fetch(`${API_BASE}/prompts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(promptData)
                });

                if (!response.ok) {
                    throw new Error('Failed to save prompt');
                }

                alert('Prompt saved successfully!');
                closeSavePrompt();
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        // Edit prompt dialog
        async function editPromptDialog(promptId) {
            try {
                const response = await fetch(`${API_BASE}/prompts/${promptId}`);
                if (!response.ok) {
                    throw new Error('Failed to load prompt');
                }

                const prompt = await response.json();

                // Fill edit form
                document.getElementById('editPromptId').value = prompt.id;
                document.getElementById('editPromptTitle').value = prompt.title;
                document.getElementById('editPromptCategory').value = prompt.category || '';
                document.getElementById('editPromptTags').value = prompt.tags || '';
                document.getElementById('editPromptContent').value = prompt.content;

                // Close library, open edit modal
                closePromptLibrary();
                document.getElementById('editPromptModal').classList.add('show');
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        // Close edit prompt modal
        function closeEditPrompt() {
            document.getElementById('editPromptModal').classList.remove('show');
        }

        // Update prompt
        async function updatePrompt() {
            const id = document.getElementById('editPromptId').value;
            const title = document.getElementById('editPromptTitle').value.trim();
            const category = document.getElementById('editPromptCategory').value;
            const tags = document.getElementById('editPromptTags').value.trim();
            const content = document.getElementById('editPromptContent').value.trim();

            if (!title || !content) {
                alert('Title and content are required');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/prompts/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title,
                        content,
                        category: category || null,
                        tags: tags || null
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to update prompt');
                }

                alert('Prompt updated successfully!');
                closeEditPrompt();
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        // Delete prompt
        async function deletePrompt() {
            const id = document.getElementById('editPromptId').value;

            if (!confirm('Are you sure you want to delete this prompt?')) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/prompts/${id}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error('Failed to delete prompt');
                }

                alert('Prompt deleted successfully!');
                closeEditPrompt();
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        // Close modals when clicking outside
        document.getElementById('promptLibraryModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closePromptLibrary();
            }
        });

        document.getElementById('savePromptModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeSavePrompt();
            }
        });

        document.getElementById('editPromptModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeEditPrompt();
            }
        });

        // New message input functions for persistent text input
        function handleMessageKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Prevent duplicate submissions
        let isSubmittingMessage = false;

        async function sendMessage() {
            console.log('üîç sendMessage() called');
            console.log('üîç currentTaskName:', currentTaskName);
            console.log('üîç messageInput value:', document.getElementById('messageInput')?.value);

            // Prevent double submission
            if (isSubmittingMessage) {
                console.log('Message submission already in progress, ignoring duplicate request');
                return;
            }

            const input = document.getElementById('messageInput').value.trim();
            if (!input) {
                alert('Please enter a message');
                return;
            }
            if (!currentTaskName) {
                console.log('‚ùå No current task selected in list view');
                // Try to find the first available task and open its conversation
                const firstTaskRow = document.querySelector('tbody tr');
                if (firstTaskRow) {
                    const taskNameCell = firstTaskRow.querySelector('td:first-child');
                    if (taskNameCell) {
                        const firstTaskName = taskNameCell.textContent.trim();
                        console.log('üîç Auto-opening conversation for first task:', firstTaskName);

                        // Open the conversation for the first task
                        viewConversation(firstTaskName);

                        // Queue the message to be sent after conversation loads
                        setTimeout(() => {
                            if (document.getElementById('messageInput').value.trim()) {
                                sendMessage();
                            }
                        }, 500);
                        return;
                    }
                }
                alert('No task selected. Please click "View Conversation" on a task first, or create a new task.');
                return;
            }

            isSubmittingMessage = true;

            try {
                // First, get task status to determine the correct messaging approach
                const statusResponse = await fetch(`${API_BASE}/tasks/by-name/${currentTaskName}/status`);
                if (!statusResponse.ok) {
                    throw new Error('Failed to get task status');
                }
                const taskStatus = await statusResponse.json();

                // Set the input message
                const setInputResponse = await fetch(`${API_BASE}/tasks/by-name/${currentTaskName}/set-input`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ input })
                });
                if (!setInputResponse.ok) {
                    throw new Error('Failed to set message');
                }

                // Smart logic based on task status:
                // - For RUNNING/PAUSED tasks: Just set input (executor will pick it up automatically)
                // - For STOPPED tasks: Set input AND resume (to restart the task)
                // - For other states: Only set input (no resume needed)
                if (taskStatus.status === 'STOPPED') {
                    // Only resume STOPPED tasks
                    const resumeResponse = await fetch(`${API_BASE}/tasks/by-name/${currentTaskName}/resume`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    if (!resumeResponse.ok) {
                        throw new Error('Failed to resume stopped task');
                    }
                }
                // For RUNNING/PAUSED tasks, the executor loop will automatically pick up the message
                // No need to call resume - that's what was causing the error!

                // Success! Clear the input and refresh conversation
                document.getElementById('messageInput').value = '';

                // Wait a moment for the message to be processed, then refresh the conversation
                setTimeout(async () => {
                    await loadConversation(currentTaskName, true);
                }, 1000);
            } catch (error) {
                alert(`Error: ${error.message}`);
            } finally {
                // Always reset the flag to allow future submissions
                isSubmittingMessage = false;
            }
        }

        // Tab view message functions
        function handleTabMessageKeyPress(event, taskName) {
            if (event.key === 'Enter') {
                sendTabMessage(taskName);
            }
        }

        function sendTabMessageFromInput() {
            console.log('üîç sendTabMessageFromInput() called');
            const viewMode = document.querySelector('input[name="viewMode"]:checked')?.value;
            console.log('üîç Current view mode:', viewMode);

            // Check if we're in List view - if so, do nothing silently
            if (viewMode === 'list') {
                console.log('üîç In list view, silently ignoring tab message send');
                return; // Silently ignore in List view
            }

            // Get the currently active task from the tabs
            let activeTab = document.querySelector('.task-tab.active');
            console.log('Active tab found:', activeTab?.getAttribute('data-task-name') || 'none');
            if (!activeTab) {
                // Fallback: try to find any tab that's currently displayed
                const allTabs = document.querySelectorAll('.task-tab');
                console.log('No active tab found, available tabs:', Array.from(allTabs).map(t => t.getAttribute('data-task-name')));

                if (allTabs.length > 0) {
                    // Use the first available tab and make it active
                    activeTab = allTabs[0];
                    const taskName = activeTab.getAttribute('data-task-name');
                    console.log('üîç Auto-selecting first tab:', taskName);

                    // Use selectTab to properly activate the tab (this ensures proper state management)
                    selectTab(taskName);

                    // After selecting the tab, call sendTabMessage
                    setTimeout(() => {
                        sendTabMessage(taskName);
                    }, 100); // Small delay to ensure tab selection completes
                    return;
                } else {
                    console.log('‚ùå No tabs available to send message to');
                    alert('No tasks available. Please create a task first.');
                    return;
                }
            }
            const taskName = activeTab.getAttribute('data-task-name');
            if (!taskName) {
                console.log('‚ùå Active tab found but no task name attribute');
                alert('Error: Selected tab has no task name. Please try selecting a different tab.');
                return;
            }
            console.log('üîç Sending message to active tab:', taskName);
            // Call the existing sendTabMessage function with the task name
            sendTabMessage(taskName);
        }

        async function sendTabMessage(taskName) {
            // Prevent double submission
            if (isSubmittingMessage) {
                console.log('‚ùå SEND TAB MESSAGE: Submission already in progress, ignoring duplicate request');
                return;
            }

            const inputElement = document.getElementById('tabMessageInput');
            const input = inputElement ? inputElement.value.trim() : '';

            console.log('=== SEND MESSAGE DEBUG ===');
            console.log('Task name:', taskName);
            console.log('Input element found:', !!inputElement);
            console.log('Input element ID:', inputElement?.id);
            console.log('Raw input value:', inputElement?.value);
            console.log('Trimmed input value:', input);
            console.log('Input element placeholder:', inputElement?.placeholder);
            console.log('Current tab view mode:', document.querySelector('input[name="viewMode"]:checked')?.value);
            console.log('Active tab:', document.querySelector('.task-tab.active')?.dataset?.taskName);
            console.log('=== END SEND MESSAGE DEBUG ===');

            if (!input) {
                console.log('‚ùå SEND MESSAGE: No input provided');
                alert('Please enter a message');
                return;
            }

            isSubmittingMessage = true;
            console.log('‚úÖ SEND MESSAGE: Starting API calls for task:', taskName);

            try {
                // Get task status
                console.log('üîç SEND MESSAGE: Getting task status...');
                const statusResponse = await fetch(`${API_BASE}/tasks/by-name/${taskName}/status`);
                console.log('üìä SEND MESSAGE: Status response status:', statusResponse.status);
                if (!statusResponse.ok) {
                    console.error('‚ùå SEND MESSAGE: Failed to get task status, response:', statusResponse);
                    throw new Error('Failed to get task status');
                }
                const taskStatus = await statusResponse.json();
                console.log('üìã SEND MESSAGE: Task status:', taskStatus.status);

                // Set the input message
                console.log('üìù SEND MESSAGE: Setting input message...');
                const setInputResponse = await fetch(`${API_BASE}/tasks/by-name/${taskName}/set-input`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ input })
                });
                console.log('üìù SEND MESSAGE: Set input response status:', setInputResponse.status);
                if (!setInputResponse.ok) {
                    console.error('‚ùå SEND MESSAGE: Failed to set message, response:', setInputResponse);
                    const errorData = await setInputResponse.json();
                    console.error('‚ùå SEND MESSAGE: Error details:', errorData);
                    throw new Error(`Failed to set message: ${errorData.detail || 'Unknown error'}`);
                }
                console.log('‚úÖ SEND MESSAGE: Input message set successfully');

                // Resume stopped tasks
                if (taskStatus.status === 'STOPPED') {
                    const resumeResponse = await fetch(`${API_BASE}/tasks/by-name/${taskName}/resume`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    if (!resumeResponse.ok) {
                        throw new Error('Failed to resume stopped task');
                    }
                }

                // Clear input and refresh conversation
                document.getElementById('tabMessageInput').value = '';

                // Refresh the tab content only if this is the currently active tab
                const activeTab = document.querySelector('.task-tab.active');
                if (activeTab && activeTab.dataset.taskName === taskName) {
                    setTimeout(() => {
                        selectTab(taskName);
                    }, 1000);
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
            } finally {
                // Always reset the flag to allow future submissions
                isSubmittingMessage = false;
            }
        }

        // List view conversation functions - for inline conversation in task cards
        function handleListMessageKeyPress(event, taskName) {
            if (event.key === 'Enter') {
                sendListMessage(taskName);
            }
        }

        async function sendListMessage(taskName) {
            const input = document.getElementById(`listMessageInput_${taskName}`).value.trim();
            if (!input) {
                alert('Please enter a message');
                return;
            }

            try {
                // Get task status
                const statusResponse = await fetch(`${API_BASE}/tasks/by-name/${taskName}/status`);
                if (!statusResponse.ok) {
                    throw new Error('Failed to get task status');
                }
                const taskStatus = await statusResponse.json();

                // Set the input message
                const setInputResponse = await fetch(`${API_BASE}/tasks/by-name/${taskName}/set-input`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ input })
                });
                if (!setInputResponse.ok) {
                    throw new Error('Failed to set message');
                }

                // Resume stopped tasks
                if (taskStatus.status === 'STOPPED') {
                    const resumeResponse = await fetch(`${API_BASE}/tasks/by-name/${taskName}/resume`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    if (!resumeResponse.ok) {
                        throw new Error('Failed to resume stopped task');
                    }
                }

                // Clear input and refresh tasks to show the new message
                document.getElementById(`listMessageInput_${taskName}`).value = '';

                // Refresh the task list to show updated conversation
                setTimeout(() => {
                    refreshTasksKeepingTab();
                }, 1000);
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        // Conversation Navigation Helper Functions
        function getIndicatorClass(interactionType) {
            const type = interactionType.toLowerCase();
            if (type === 'human' || type === 'user') {
                return 'human';
            } else if (type === 'claude' || type === 'assistant') {
                return 'claude';
            } else if (type === 'system') {
                return 'system';
            } else if (type === 'tool' || type === 'tool_result') {
                return 'tool';
            } else {
                return 'claude'; // Default to claude for unknown types
            }
        }

        // Timestamp to prevent auto-scroll interference immediately after mini-map clicks
        let lastMiniMapClickTime = 0;

        // Function to force scroll to absolute top - for debugging
        function forceScrollToTop() {
            console.log('=== FORCE SCROLL TO TOP DEBUG ===');

            // Try to scroll all potential parent containers
            const containers = [
                document.getElementById('tabConversationContainer'),
                document.getElementById('taskContent'),
                document.querySelector('.tab-container'),
                document.getElementById('tasksTabView'),
                document.body,
                document.documentElement
            ];

            containers.forEach((container, index) => {
                if (container) {
                    const name = container.id || container.className || `container-${index}`;
                    console.log(`--- Scrolling ${name} ---`);
                    console.log('Before:', container.scrollTop);
                    container.scrollTop = 0;
                    console.log('After:', container.scrollTop);
                }
            });

            // Also try scrolling the tabs into view
            const tabsElement = document.getElementById('taskTabs');
            if (tabsElement) {
                console.log('--- Scrolling tabs into view ---');
                tabsElement.scrollIntoView({behavior: 'instant', block: 'start'});
            }

            // Try scrolling window to top as well
            console.log('--- Scrolling window to top ---');
            window.scrollTo(0, 0);
        }

        // Add keyboard shortcut for testing (Ctrl+Home)
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'Home') {
                e.preventDefault();
                console.log('Ctrl+Home pressed - forcing scroll to top');
                forceScrollToTop();
            }
        });

        function scrollToConversationItem(index, providedContainer = null) {
            // Record the time to prevent auto-scroll interference for a brief moment
            lastMiniMapClickTime = Date.now();

            const targetElement = document.getElementById(`conversation-item-${index}`);

            // Use provided container or find the correct conversation container
            let conversationContainer = providedContainer;
            if (!conversationContainer) {
                conversationContainer = document.getElementById('tabConversationContainer');
                if (!conversationContainer) {
                    conversationContainer = document.getElementById('conversationContent');
                }
            }

            console.log('=== MINIMAP CLICK DEBUG ===');
            console.log('Clicked index:', index);
            console.log('Target element ID:', `conversation-item-${index}`);
            console.log('Target element found:', !!targetElement);
            console.log('Container found:', !!conversationContainer);
            console.log('Container ID:', conversationContainer?.id);
            console.log('Container scrollTop (before):', conversationContainer?.scrollTop);
            console.log('Container scrollHeight:', conversationContainer?.scrollHeight);
            console.log('Container clientHeight:', conversationContainer?.clientHeight);

            if (targetElement && conversationContainer) {

                // Simple and reliable scroll calculation using offsetTop
                const targetTop = targetElement.offsetTop;
                const containerHeight = conversationContainer.clientHeight;
                const targetHeight = targetElement.offsetHeight;

                console.log('Target offsetTop:', targetTop);
                console.log('Container height:', containerHeight);
                console.log('Target height:', targetHeight);

                // Simple scroll calculation - just scroll to the element position
                let scrollPosition;

                // For the first item (index 0), scroll to the very top of the parent container
                if (index === 0) {
                    scrollPosition = 0;
                    console.log('Target is first item - forcing scroll to absolute top');

                    // Also scroll the parent taskContent container to show tabs
                    const taskContent = document.getElementById('taskContent');
                    if (taskContent) {
                        taskContent.scrollTop = 0;
                        console.log('Also scrolled taskContent to top to show tabs');
                    }

                    // Also scroll the main window/body to the very top to show Add Task buttons
                    window.scrollTo(0, 0);
                    document.body.scrollTop = 0;
                    document.documentElement.scrollTop = 0;
                    console.log('Also scrolled main window to top to show Add Task buttons');
                } else {
                    // For other items, scroll to their position (not centering)
                    scrollPosition = targetTop;
                }

                // Ensure scroll position is within valid bounds
                const scrollHeight = conversationContainer.scrollHeight;
                const maxScroll = Math.max(0, scrollHeight - containerHeight);

                // Debug the scrolling issue
                console.log('Scrollability check:', {
                    scrollHeight,
                    containerHeight,
                    difference: scrollHeight - containerHeight,
                    maxScroll,
                    isScrollable: scrollHeight > containerHeight,
                    computedStyle: getComputedStyle(conversationContainer).overflowY
                });

                let finalScrollTop = Math.max(0, Math.min(scrollPosition, maxScroll));

                // If maxScroll is 0 but we want to scroll, force it
                if (maxScroll === 0 && scrollPosition > 0) {
                    console.log('WARNING: Container appears non-scrollable but we want to scroll. Forcing scroll...');
                    finalScrollTop = scrollPosition;
                }

                console.log('Scroll height:', scrollHeight);
                console.log('Container scrollHeight:', conversationContainer.scrollHeight);
                console.log('Container clientHeight:', conversationContainer.clientHeight);
                console.log('Container offsetHeight:', conversationContainer.offsetHeight);

                console.log('Calculated scroll position:', scrollPosition);
                console.log('Max possible scroll:', maxScroll);
                console.log('Final scroll position:', finalScrollTop);
                console.log('Current scroll position:', conversationContainer.scrollTop);

                // Try multiple scrolling approaches for reliability
                try {
                    // Method 1: Direct scrollTop setting
                    conversationContainer.scrollTop = finalScrollTop;
                    console.log('Method 1 - Set container scrollTop to:', finalScrollTop);
                    console.log('Method 1 - New container scrollTop is:', conversationContainer.scrollTop);

                    // Method 2: Use scrollIntoView as fallback
                    if (conversationContainer.scrollTop !== finalScrollTop) {
                        console.log('Method 1 failed, trying scrollIntoView...');
                        targetElement.scrollIntoView({
                            behavior: 'instant',
                            block: 'start',
                            inline: 'nearest'
                        });
                        console.log('Method 2 - After scrollIntoView, scrollTop is:', conversationContainer.scrollTop);
                    }

                    // Method 3: Force with requestAnimationFrame
                    if (conversationContainer.scrollTop === 0 && finalScrollTop > 0) {
                        console.log('Both methods failed, forcing with requestAnimationFrame...');
                        requestAnimationFrame(() => {
                            conversationContainer.scrollTop = finalScrollTop;
                            console.log('Method 3 - Forced scrollTop to:', finalScrollTop);
                            console.log('Method 3 - Final scrollTop is:', conversationContainer.scrollTop);
                        });
                    }
                } catch (e) {
                    console.log('All scrolling methods failed:', e);
                }

                console.log('Container scrollTop (after):', conversationContainer.scrollTop);
                console.log('=== END MINIMAP CLICK DEBUG ===');

                // Temporarily highlight the target element with stronger visual feedback
                targetElement.style.transition = 'all 0.3s ease';
                targetElement.style.backgroundColor = '#fef3c7';
                targetElement.style.border = '2px solid #f59e0b';
                targetElement.style.borderRadius = '4px';
                console.log('Applied highlight to target element');

                // Mini-map scroll completed - auto-scroll protection will expire automatically after 200ms

                setTimeout(() => {
                    targetElement.style.backgroundColor = '';
                    targetElement.style.border = '';
                    targetElement.style.borderRadius = '';
                    setTimeout(() => {
                        targetElement.style.transition = '';
                    }, 300);
                }, 2000);
            } else {
                console.error('Missing elements for scroll:', {
                    targetElement: !!targetElement,
                    conversationContainer: !!conversationContainer,
                    targetId: `conversation-item-${index}`,
                    availableElements: document.querySelectorAll('[id^="conversation-item-"]').length
                });

                // List all available conversation items for debugging
                const allItems = document.querySelectorAll('[id^="conversation-item-"]');
                console.log('Available conversation items:', Array.from(allItems).map(el => el.id));
            }
        }

        function setupConversationMinimap(conversation, minimapId = 'conversationMinimap', containerId = 'tabConversationContainer') {

            let minimap = document.getElementById(minimapId);
            let conversationContainer = document.getElementById(containerId);

            // Smart fallback: If tab minimap doesn't exist but modal minimap does, use modal minimap
            if (!minimap && minimapId === 'conversationMinimap') {
                const modalMinimap = document.getElementById('conversationMinimapModal');
                if (modalMinimap) {
                    console.log('Tab minimap not found, falling back to modal minimap');
                    minimap = modalMinimap;
                    minimapId = 'conversationMinimapModal';
                }
            }

            // Smart fallback: If tab container doesn't exist but conversationContent does, use conversationContent
            if (!conversationContainer && containerId === 'tabConversationContainer') {
                const contentContainer = document.getElementById('conversationContent');
                if (contentContainer) {
                    console.log('Tab container not found, falling back to conversationContent');
                    conversationContainer = contentContainer;
                    containerId = 'conversationContent';
                }
            }

            if (!minimap || !conversationContainer) {
                console.log('Missing elements for minimap setup (after fallback):', {
                    minimapId,
                    containerId,
                    minimap: !!minimap,
                    container: !!conversationContainer,
                    minimapElement: minimap,
                    containerElement: conversationContainer
                });

                // Debug: List all available elements with these IDs
                console.log('Available elements check:');
                console.log('- conversationMinimap:', !!document.getElementById('conversationMinimap'));
                console.log('- conversationMinimapModal:', !!document.getElementById('conversationMinimapModal'));
                console.log('- tabConversationContainer:', !!document.getElementById('tabConversationContainer'));
                console.log('- conversationContent:', !!document.getElementById('conversationContent'));

                return;
            }

            // Always show minimap, even if conversation is empty (especially for running tasks)
            if (conversation.length === 0) {
                console.log('No conversation yet, but setting up empty minimap for running task');
                // Create minimal minimap structure with appropriate viewport indicator ID
                const viewportIndicatorId = minimapId.includes('Modal') ? 'viewportIndicatorModal' : 'viewportIndicator';
                minimap.innerHTML = `<div class="conversation-viewport-indicator" id="${viewportIndicatorId}"></div>`;
                return;
            }

            // Calculate total conversation height by summing actual message heights
            const conversationItems = conversationContainer.querySelectorAll('.conversation-item');
            let totalHeight = conversationContainer.scrollHeight;


            // Clear minimap and add conversation items with appropriate viewport indicator ID
            const viewportIndicatorId = minimapId.includes('Modal') ? 'viewportIndicatorModal' : 'viewportIndicator';
            minimap.innerHTML = `<div class="conversation-viewport-indicator" id="${viewportIndicatorId}"></div>`;

            // Filter for only meaningful messages: human, claude non-tool, and tool results
            const meaningfulMessages = conversation.filter((interaction, index) => {
                const type = interaction.type.toLowerCase();
                return (
                    type === 'human' ||
                    type === 'user' ||
                    type === 'user_request' ||
                    type === 'claude' ||
                    type === 'assistant' ||
                    type === 'claude_response' ||
                    type === 'tool_result'
                );
            });


            meaningfulMessages.forEach((interaction, filteredIndex) => {
                // Find original index in the full conversation
                const originalIndex = conversation.findIndex(item => item === interaction);

                const minimapItem = document.createElement('div');
                minimapItem.className = `conversation-minimap-item ${getMinimapClass(interaction.type)}`;
                minimapItem.dataset.index = originalIndex;

                // Calculate proportional height for this item
                const actualItem = document.getElementById(`conversation-item-${originalIndex}`);
                const itemHeight = actualItem ? actualItem.offsetHeight : 50;
                const proportionalHeight = Math.max(4, (itemHeight / totalHeight) * minimap.offsetHeight);

                minimapItem.style.height = proportionalHeight + 'px';

                // Add hover tooltip
                minimapItem.addEventListener('mouseenter', () => {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'nav-tooltip';
                    tooltip.textContent = getTooltipText(interaction.type);
                    tooltip.style.position = 'fixed';
                    tooltip.style.left = '0px';
                    tooltip.style.top = (minimapItem.getBoundingClientRect().top + window.scrollY) + 'px';
                    tooltip.style.transform = 'translateX(-100%)';
                    tooltip.style.backgroundColor = '#333';
                    tooltip.style.color = 'white';
                    tooltip.style.padding = '4px 8px';
                    tooltip.style.borderRadius = '4px';
                    tooltip.style.fontSize = '12px';
                    tooltip.style.whiteSpace = 'nowrap';
                    tooltip.style.zIndex = '1000';
                    tooltip.style.marginLeft = '-8px';
                    document.body.appendChild(tooltip);
                    minimapItem.tooltip = tooltip;
                });

                minimapItem.addEventListener('mouseleave', () => {
                    if (minimapItem.tooltip) {
                        minimapItem.tooltip.remove();
                        minimapItem.tooltip = null;
                    }
                });

                // Add click handler with enhanced debugging
                minimapItem.addEventListener('click', () => {
                    console.log('Minimap item clicked:', {
                        originalIndex,
                        interactionType: interaction.type,
                        filteredIndex,
                        containerId: containerId
                    });

                    // Highlight the minimap item being clicked
                    minimapItem.style.border = '2px solid #3b82f6';
                    setTimeout(() => {
                        minimapItem.style.border = '';
                    }, 1000);

                    scrollToConversationItem(originalIndex, conversationContainer);
                });

                minimap.appendChild(minimapItem);
            });

            // Add click handler to minimap container for clicks on empty space
            // This handles clicking at the bottom of the minimap to scroll to conversation bottom
            minimap.addEventListener('click', (event) => {
                console.log('Minimap clicked - event details:', {
                    target: event.target,
                    currentTarget: event.currentTarget,
                    targetTagName: event.target.tagName,
                    targetClassName: event.target.className,
                    minimapElement: minimap,
                    isMinimapTarget: event.target === minimap,
                    hasMinimapItemClass: event.target.classList.contains('minimap-item')
                });

                // Handle clicks on minimap container OR any non-minimap-item child
                // This ensures we catch clicks on empty space even if there are other child elements
                const isMinimapItem = event.target.classList && event.target.classList.contains('minimap-item');

                if (!isMinimapItem) {
                    console.log('Minimap container/empty space clicked');

                    const minimapRect = minimap.getBoundingClientRect();
                    const clickY = event.clientY - minimapRect.top;
                    const minimapHeight = minimapRect.height;

                    // Calculate proportional position (0 = top, 1 = bottom)
                    const proportionalPosition = Math.max(0, Math.min(1, clickY / minimapHeight));

                    console.log('Minimap empty space click details:', {
                        clickY,
                        minimapHeight,
                        proportionalPosition,
                        containerId,
                        clientY: event.clientY,
                        minimapTop: minimapRect.top
                    });

                    // Map to conversation scroll position
                    const scrollHeight = conversationContainer.scrollHeight;
                    const containerHeight = conversationContainer.clientHeight;
                    const maxScroll = Math.max(0, scrollHeight - containerHeight);

                    // Calculate target scroll position
                    let targetScrollTop = proportionalPosition * maxScroll;

                    // Special case: if clicking very close to bottom (90%+), force scroll to absolute bottom
                    if (proportionalPosition >= 0.9) {
                        targetScrollTop = maxScroll;
                        console.log('Click near bottom detected (>90%), forcing scroll to absolute bottom');
                    }

                    console.log('Proportional scroll mapping:', {
                        scrollHeight,
                        containerHeight,
                        maxScroll,
                        targetScrollTop,
                        currentScrollTop: conversationContainer.scrollTop,
                        willScrollToBottom: proportionalPosition >= 0.9
                    });

                    // Record click time to prevent auto-scroll interference
                    lastMiniMapClickTime = Date.now();

                    // Apply scroll
                    conversationContainer.scrollTop = targetScrollTop;

                    console.log('Applied scroll - new scrollTop:', conversationContainer.scrollTop);

                    // Prevent event from bubbling to avoid interfering with other handlers
                    event.stopPropagation();
                } else {
                    console.log('Minimap item clicked, letting default handler take over');
                }
            });

            // Setup viewport indicator updates
            setupViewportIndicator();
            updateViewportIndicator();

            // Update viewport indicator on scroll
            conversationContainer.addEventListener('scroll', updateViewportIndicator);

        }

        function showTooltip(indicator, text) {
            console.log('showTooltip called with text:', text, 'indicator:', indicator);

            // Remove any existing tooltip
            const existingTooltip = indicator.querySelector('.nav-tooltip');
            if (existingTooltip) {
                console.log('Removing existing tooltip');
                existingTooltip.remove();
            }

            // Create new tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'nav-tooltip';
            tooltip.textContent = text;
            indicator.appendChild(tooltip);

            console.log('Created tooltip element:', tooltip, 'parent:', indicator);

            // Show tooltip with a slight delay for smooth animation
            setTimeout(() => {
                tooltip.classList.add('show');
                console.log('Added show class to tooltip, classes:', tooltip.className);
            }, 10);
        }

        function hideTooltip(indicator) {
            const tooltip = indicator.querySelector('.nav-tooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
                setTimeout(() => {
                    tooltip.remove();
                }, 150); // Match transition duration
            }
        }

        function getMinimapClass(interactionType) {
            const type = interactionType.toLowerCase();
            if (type === 'human' || type === 'user' || type === 'user_request') {
                return 'human';
            } else if (type === 'claude' || type === 'assistant' || type === 'claude_response') {
                return 'claude';
            } else if (type === 'system') {
                return 'system';
            } else if (type === 'tool' || type === 'tool_result') {
                return 'tool';
            } else {
                return 'claude'; // Default to claude for unknown types
            }
        }

        function getTooltipText(interactionType) {
            const type = interactionType.toLowerCase();
            if (type === 'human' || type === 'user' || type === 'user_request') {
                return 'Human Message';
            } else if (type === 'claude' || type === 'assistant' || type === 'claude_response') {
                return 'Claude Response';
            } else if (type === 'system') {
                return 'System Message';
            } else if (type === 'tool' || type === 'tool_result') {
                return 'Tool Result';
            } else {
                return 'Message';
            }
        }

        function setupViewportIndicator() {
            const conversationContainer = document.getElementById('tabConversationContainer');
            if (conversationContainer) {
                conversationContainer.addEventListener('scroll', updateViewportIndicator);
                window.addEventListener('resize', updateViewportIndicator);
            }
        }

        function updateViewportIndicator() {
            const conversationContainer = document.getElementById('tabConversationContainer');
            const minimap = document.getElementById('conversationMinimap');
            const viewportIndicator = document.getElementById('viewportIndicator');

            if (!conversationContainer || !minimap || !viewportIndicator) {
                return;
            }

            const containerHeight = conversationContainer.clientHeight;
            const scrollHeight = conversationContainer.scrollHeight;
            const scrollTop = conversationContainer.scrollTop;
            const minimapHeight = minimap.clientHeight;

            // Calculate viewport indicator position and size
            const viewportRatio = containerHeight / scrollHeight;
            const scrollRatio = scrollTop / scrollHeight;

            const indicatorHeight = Math.max(20, viewportRatio * minimapHeight);
            const indicatorTop = scrollRatio * minimapHeight;

            viewportIndicator.style.height = indicatorHeight + 'px';
            viewportIndicator.style.top = indicatorTop + 'px';

        }

        // ============================================================================
        // Batch Selection Functions
        // ============================================================================

        // Track selection state
        let selectedTasks = new Set();

        // Update selection state and UI
        function updateSelection() {
            const checkboxes = document.querySelectorAll('.task-selector');
            const checkedBoxes = document.querySelectorAll('.task-selector:checked');

            // Update selectedTasks set
            selectedTasks.clear();
            checkedBoxes.forEach(checkbox => {
                selectedTasks.add(checkbox.dataset.taskName);
            });

            // Update UI
            updateSelectionUI();
        }

        // Update selection UI elements
        function updateSelectionUI() {
            const selectedCount = selectedTasks.size;

            // Get elements for List view only
            const batchToolbar = document.getElementById('batchToolbar');
            const selectedCountSpan = document.getElementById('selectedCount');
            const selectAllCheckbox = document.getElementById('selectAllTasks');
            const taskCheckboxes = document.querySelectorAll('.task-selector');

            // Update List view elements (if they exist)
            if (batchToolbar && selectedCountSpan && selectAllCheckbox) {
                selectedCountSpan.textContent = selectedCount;
                if (selectedCount > 0) {
                    batchToolbar.classList.add('visible');
                } else {
                    batchToolbar.classList.remove('visible');
                }

                // Update select all checkbox state
                if (selectedCount === 0) {
                    selectAllCheckbox.indeterminate = false;
                    selectAllCheckbox.checked = false;
                } else if (selectedCount === taskCheckboxes.length) {
                    selectAllCheckbox.indeterminate = false;
                    selectAllCheckbox.checked = true;
                } else {
                    selectAllCheckbox.indeterminate = true;
                    selectAllCheckbox.checked = false;
                }
            }
        }

        // Toggle select all
        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllTasks');
            const taskCheckboxes = document.querySelectorAll('.task-selector');

            const shouldSelectAll = selectAllCheckbox.checked;

            taskCheckboxes.forEach(checkbox => {
                checkbox.checked = shouldSelectAll;
            });

            updateSelection();
        }

        // Clear selection
        function clearSelection() {
            document.querySelectorAll('.task-selector:checked').forEach(checkbox => {
                checkbox.checked = false;
            });
            updateSelection();
        }

        // Get selected task names
        function getSelectedTaskNames() {
            return Array.from(selectedTasks);
        }

        // Batch start tasks
        async function batchStartTasks() {
            const taskNames = getSelectedTaskNames();
            if (taskNames.length === 0) return;

            if (!confirm(`Start ${taskNames.length} selected task(s)?`)) return;

            const results = [];
            for (const taskName of taskNames) {
                try {
                    await fetch(`${API_BASE}/tasks/by-name/${taskName}/start`, { method: 'POST' });
                    results.push({ task: taskName, success: true });
                } catch (error) {
                    results.push({ task: taskName, success: false, error: error.message });
                }
            }

            // Show results
            const successful = results.filter(r => r.success).length;
            const failed = results.filter(r => !r.success).length;

            let message = `Batch start completed: ${successful} successful`;
            if (failed > 0) {
                message += `, ${failed} failed`;
            }

            alert(message);
            clearSelection();
            refreshTasksKeepingTab();
        }

        // Batch clear and restart tasks
        async function batchClearAndRestartTasks() {
            const taskNames = getSelectedTaskNames();
            if (taskNames.length === 0) return;

            const taskList = taskNames.join('\n‚Ä¢ ');
            if (!confirm(`Clear & Restart ${taskNames.length} selected task(s)?\n\nThis will clear conversation history and restart:\n‚Ä¢ ${taskList}\n\nThis action cannot be undone.`)) return;

            const results = [];
            for (const taskName of taskNames) {
                try {
                    await fetch(`${API_BASE}/tasks/by-name/${taskName}/clear-and-restart`, { method: 'POST' });
                    results.push({ task: taskName, success: true });
                } catch (error) {
                    results.push({ task: taskName, success: false, error: error.message });
                }
            }

            // Show results
            const successful = results.filter(r => r.success).length;
            const failed = results.filter(r => !r.success).length;

            let message = `Batch clear & restart completed: ${successful} successful`;
            if (failed > 0) {
                message += `, ${failed} failed`;
            }

            alert(message);
            clearSelection();
            refreshTasksKeepingTab();
        }

        // Batch delete tasks
        async function batchDeleteTasks() {
            const taskNames = getSelectedTaskNames();
            if (taskNames.length === 0) return;

            const taskList = taskNames.join('\n‚Ä¢ ');
            if (!confirm(`Delete ${taskNames.length} selected task(s)?\n\nThis will permanently delete:\n‚Ä¢ ${taskList}\n\nThis action cannot be undone.`)) return;

            try {
                const response = await fetch(`${API_BASE}/tasks/batch-delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ task_names: taskNames, cleanup_worktree: true })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Batch delete failed');
                }

                const result = await response.json();

                let message = `Batch delete completed: ${result.successful} successful`;
                if (result.failed > 0) {
                    message += `, ${result.failed} failed`;
                    const failedTasks = result.results.filter(r => !r.success);
                    if (failedTasks.length > 0) {
                        message += '\n\nFailed tasks:\n‚Ä¢ ' + failedTasks.map(t => `${t.task_name}: ${t.error}`).join('\n‚Ä¢ ');
                    }
                }

                alert(message);
            } catch (error) {
                alert(`Batch delete error: ${error.message}`);
            }

            clearSelection();
            refreshTasksKeepingTab();
        }

        // Batch refresh tasks
        async function batchRefreshTasks() {
            const taskNames = getSelectedTaskNames();
            if (taskNames.length === 0) return;

            // Just refresh the task list - this will update all tasks
            refreshTasksKeepingTab();
            clearSelection();
        }

        // Initialize selection state when tasks are loaded
        function initializeSelection() {
            // Clear selection state
            selectedTasks.clear();
            updateSelectionUI();
        }

        // Call initialize selection after loading tasks (modify existing loadTasks)
        const originalLoadTasks = loadTasks;
        loadTasks = async function() {
            await originalLoadTasks();
            // Only initialize selection if we're in list view
            if (document.getElementById('tasksList').style.display !== 'none') {
                setTimeout(initializeSelection, 100); // Small delay to ensure DOM is updated
            }
        };
    </script>
</body>
</html>
